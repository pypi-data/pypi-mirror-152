"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import anki.collection_pb2
import anki.generic_pb2
import anki.notes_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class ImportCollectionPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COL_PATH_FIELD_NUMBER: builtins.int
    BACKUP_PATH_FIELD_NUMBER: builtins.int
    MEDIA_FOLDER_FIELD_NUMBER: builtins.int
    MEDIA_DB_FIELD_NUMBER: builtins.int
    col_path: typing.Text
    backup_path: typing.Text
    media_folder: typing.Text
    media_db: typing.Text
    def __init__(self,
        *,
        col_path: typing.Text = ...,
        backup_path: typing.Text = ...,
        media_folder: typing.Text = ...,
        media_db: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["backup_path",b"backup_path","col_path",b"col_path","media_db",b"media_db","media_folder",b"media_folder"]) -> None: ...
global___ImportCollectionPackageRequest = ImportCollectionPackageRequest

class ExportCollectionPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OUT_PATH_FIELD_NUMBER: builtins.int
    INCLUDE_MEDIA_FIELD_NUMBER: builtins.int
    LEGACY_FIELD_NUMBER: builtins.int
    out_path: typing.Text
    include_media: builtins.bool
    legacy: builtins.bool
    def __init__(self,
        *,
        out_path: typing.Text = ...,
        include_media: builtins.bool = ...,
        legacy: builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["include_media",b"include_media","legacy",b"legacy","out_path",b"out_path"]) -> None: ...
global___ExportCollectionPackageRequest = ExportCollectionPackageRequest

class ImportAnkiPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PACKAGE_PATH_FIELD_NUMBER: builtins.int
    package_path: typing.Text
    def __init__(self,
        *,
        package_path: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["package_path",b"package_path"]) -> None: ...
global___ImportAnkiPackageRequest = ImportAnkiPackageRequest

class ImportAnkiPackageResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Note(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ID_FIELD_NUMBER: builtins.int
        FIELDS_FIELD_NUMBER: builtins.int
        @property
        def id(self) -> anki.notes_pb2.NoteId: ...
        @property
        def fields(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
        def __init__(self,
            *,
            id: typing.Optional[anki.notes_pb2.NoteId] = ...,
            fields: typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["id",b"id"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["fields",b"fields","id",b"id"]) -> None: ...

    class Log(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NEW_FIELD_NUMBER: builtins.int
        UPDATED_FIELD_NUMBER: builtins.int
        DUPLICATE_FIELD_NUMBER: builtins.int
        CONFLICTING_FIELD_NUMBER: builtins.int
        @property
        def new(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportAnkiPackageResponse.Note]: ...
        @property
        def updated(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportAnkiPackageResponse.Note]: ...
        @property
        def duplicate(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportAnkiPackageResponse.Note]: ...
        @property
        def conflicting(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportAnkiPackageResponse.Note]: ...
        def __init__(self,
            *,
            new: typing.Optional[typing.Iterable[global___ImportAnkiPackageResponse.Note]] = ...,
            updated: typing.Optional[typing.Iterable[global___ImportAnkiPackageResponse.Note]] = ...,
            duplicate: typing.Optional[typing.Iterable[global___ImportAnkiPackageResponse.Note]] = ...,
            conflicting: typing.Optional[typing.Iterable[global___ImportAnkiPackageResponse.Note]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["conflicting",b"conflicting","duplicate",b"duplicate","new",b"new","updated",b"updated"]) -> None: ...

    CHANGES_FIELD_NUMBER: builtins.int
    LOG_FIELD_NUMBER: builtins.int
    @property
    def changes(self) -> anki.collection_pb2.OpChanges: ...
    @property
    def log(self) -> global___ImportAnkiPackageResponse.Log: ...
    def __init__(self,
        *,
        changes: typing.Optional[anki.collection_pb2.OpChanges] = ...,
        log: typing.Optional[global___ImportAnkiPackageResponse.Log] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["changes",b"changes","log",b"log"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["changes",b"changes","log",b"log"]) -> None: ...
global___ImportAnkiPackageResponse = ImportAnkiPackageResponse

class ExportAnkiPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OUT_PATH_FIELD_NUMBER: builtins.int
    WITH_SCHEDULING_FIELD_NUMBER: builtins.int
    WITH_MEDIA_FIELD_NUMBER: builtins.int
    LEGACY_FIELD_NUMBER: builtins.int
    WHOLE_COLLECTION_FIELD_NUMBER: builtins.int
    DECK_ID_FIELD_NUMBER: builtins.int
    NOTE_IDS_FIELD_NUMBER: builtins.int
    out_path: typing.Text
    with_scheduling: builtins.bool
    with_media: builtins.bool
    legacy: builtins.bool
    @property
    def whole_collection(self) -> anki.generic_pb2.Empty: ...
    deck_id: builtins.int
    @property
    def note_ids(self) -> anki.notes_pb2.NoteIds: ...
    def __init__(self,
        *,
        out_path: typing.Text = ...,
        with_scheduling: builtins.bool = ...,
        with_media: builtins.bool = ...,
        legacy: builtins.bool = ...,
        whole_collection: typing.Optional[anki.generic_pb2.Empty] = ...,
        deck_id: builtins.int = ...,
        note_ids: typing.Optional[anki.notes_pb2.NoteIds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deck_id",b"deck_id","note_ids",b"note_ids","selector",b"selector","whole_collection",b"whole_collection"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["deck_id",b"deck_id","legacy",b"legacy","note_ids",b"note_ids","out_path",b"out_path","selector",b"selector","whole_collection",b"whole_collection","with_media",b"with_media","with_scheduling",b"with_scheduling"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["selector",b"selector"]) -> typing.Optional[typing_extensions.Literal["whole_collection","deck_id","note_ids"]]: ...
global___ExportAnkiPackageRequest = ExportAnkiPackageRequest

class PackageMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Version:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _VersionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PackageMetadata._Version.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERSION_UNKNOWN: PackageMetadata._Version.ValueType  # 0
        VERSION_LEGACY_1: PackageMetadata._Version.ValueType  # 1
        """When `meta` missing, and collection.anki2 file present."""

        VERSION_LEGACY_2: PackageMetadata._Version.ValueType  # 2
        """When `meta` missing, and collection.anki21 file present."""

        VERSION_LATEST: PackageMetadata._Version.ValueType  # 3
        """Implies MediaEntry media map, and zstd compression.
        collection.21b file
        """

    class Version(_Version, metaclass=_VersionEnumTypeWrapper):
        pass

    VERSION_UNKNOWN: PackageMetadata.Version.ValueType  # 0
    VERSION_LEGACY_1: PackageMetadata.Version.ValueType  # 1
    """When `meta` missing, and collection.anki2 file present."""

    VERSION_LEGACY_2: PackageMetadata.Version.ValueType  # 2
    """When `meta` missing, and collection.anki21 file present."""

    VERSION_LATEST: PackageMetadata.Version.ValueType  # 3
    """Implies MediaEntry media map, and zstd compression.
    collection.21b file
    """


    VERSION_FIELD_NUMBER: builtins.int
    version: global___PackageMetadata.Version.ValueType
    def __init__(self,
        *,
        version: global___PackageMetadata.Version.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["version",b"version"]) -> None: ...
global___PackageMetadata = PackageMetadata

class MediaEntries(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class MediaEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        SIZE_FIELD_NUMBER: builtins.int
        SHA1_FIELD_NUMBER: builtins.int
        LEGACY_ZIP_FILENAME_FIELD_NUMBER: builtins.int
        name: typing.Text
        size: builtins.int
        sha1: builtins.bytes
        legacy_zip_filename: builtins.int
        """/ Legacy media maps may include gaps in the media list, so the original
        / file index is recorded when importing from a HashMap. This field is not
        / set when exporting.
        """

        def __init__(self,
            *,
            name: typing.Text = ...,
            size: builtins.int = ...,
            sha1: builtins.bytes = ...,
            legacy_zip_filename: typing.Optional[builtins.int] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["_legacy_zip_filename",b"_legacy_zip_filename","legacy_zip_filename",b"legacy_zip_filename"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["_legacy_zip_filename",b"_legacy_zip_filename","legacy_zip_filename",b"legacy_zip_filename","name",b"name","sha1",b"sha1","size",b"size"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_legacy_zip_filename",b"_legacy_zip_filename"]) -> typing.Optional[typing_extensions.Literal["legacy_zip_filename"]]: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MediaEntries.MediaEntry]: ...
    def __init__(self,
        *,
        entries: typing.Optional[typing.Iterable[global___MediaEntries.MediaEntry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entries",b"entries"]) -> None: ...
global___MediaEntries = MediaEntries
