#!python

# pylint: disable=line-too-long
# pylint: disable=missing-module-docstring

import os
import sys
import pkgutil
import traceback
from chiakilisp.utils import pprint
from chiakilisp.lexer import Lexer
from chiakilisp.parser import Parser
from chiakilisp.environment import ENVIRONMENT
from chiakilisp.linter.linter import BuiltinLinter
from chiakilisp.cxcompiler.dictionary import DICTIONARY
from chiakilisp.cxcompiler.cgen import CPPCodeGenerator

BUILTINS = globals()['__builtins__']
ENVIRONMENT.update({name: getattr(BUILTINS, name, None)
                    for name in dir(BUILTINS)})


def wood(source: str) -> list:  # sadly, no exact types

    """
    wood() method converts source to a wood of children

    :param source: str instance, containing source code
    :return: this method will return a wood of children
    """

    lexer = Lexer(source)
    lexer.lex()
    parser = Parser(lexer.tokens())
    parser.parse()
    return parser.wood()  # return wood of the Children


def require(path: str, merge: bool = False) -> dict:

    """
    require() method takes path as string, opens it,
    takes it to the parser, then returns module environ

    :param path: ChiakiLisp source path
    :param merge: whether to merge with global environ?
    :return: an executed module environment (as a dict)
    """

    with open(path, 'r', encoding='utf-8') as _r:
        environment = {} if not merge else ENVIRONMENT
        if not merge:
            environment.update(ENVIRONMENT)  # then do this
        for child in wood(_r.read()):
            child.execute(environment)
        return environment  # <---- return ready to use env


def execute(source: str, silent: bool = False) -> None:

    """
    execute() method convert source to AST and executes its

    :param source: ChiakiLisp valid source code as a string
    :param silent: whether print executed expression or not
    :return: returns _nothing_, only prints each result out
    """

    for child in wood(source):
        result = child.execute(ENVIRONMENT)
        if not silent:
            pprint(result)  # with the custom formatting :D


def generate(source: str, outfile_name: str) -> None:

    """
    generate() method convert source to AST and executes it

    :param source: ChiakiLisp valid source code as a string
    :param outfile_name: file's name to write CPP code into
    :return: returns _nothing, it only generates a CPP code
    """

    gvc = 0
    gss = []

    for child in wood(source):
        name = f'_global_{gvc}'
        gss.append(child.generate(DICTIONARY, name, False))
        gvc += 1

    with open(outfile_name, 'w', encoding='utf-8') as wrtr:
        wrtr.write(CPPCodeGenerator(source=gss).generate())


def repl() -> None:

    """Starts a REPL-like environment"""

    while True:
        try:
            source: str = input('LISP> ')  # later, it may be changed to the currently _active_ namespace' name
        except KeyboardInterrupt:  # handle Ctrl+D (exit the REPL)
            print()  # print an empty line to prevent Python 3 from printing next LISP> prompt on the same line
            continue
        except EOFError:  # handle Ctrl+C (cancel a current input)
            print()  # print an empty line to prevent host' shell to print their prompt string on the same line
            return
        if not source:  # if there is no source code for execute()
            continue
        try:
            execute(source)  # execute function also prints result
        except (Exception,) as _exc:  # pylint: disable=W0703        # try to catch any possible exception here
            if ENVIRONMENT.get('repl-show-traceback'):
                traceback.print_exc()
            else:
                print(_exc)  # have to manually print error (and if user want to  print out exception traceback)


if __name__ == '__main__':

    ENVIRONMENT['require'] = require  # <-- make it possible to require ChiakiLisp modules

    try:
        import readline  # pylint: disable=W0611                                     (>_<)
    except ImportError:
        readline = type('readline', (object,), {  # pylint: disable=invalid-name     (>_<)
            "set_completer": lambda _, __: None,
            "parse_and_bind": lambda _, __: None
        })  # <----------------------------------- this is for MS Windows NT compatibility

    readline.parse_and_bind("tab: complete")  # <--- allows user to complete binding names
    readline.parse_and_bind('set: blink-matching-paren on')  # <- extremely needed feature

    def completer(text, state) -> str or None:

        """Handle completions shown by GNU Readline library when the user press Tab key"""

        names = tuple(ENVIRONMENT.keys())

        return (tuple(filter(lambda name: name.startswith(text), names)) + (None,))[state]

    readline.set_completer(completer)

    rc_file = os.path.join(os.environ.get('HOME', os.environ.get('USER')), '.chiakilang-repl-rc.cl')
    if os.path.exists(rc_file):
        try:
            require(rc_file, merge=True)
        except (Exception,) as exc:  # pylint: disable=broad-except      # it's okay to this, pylint
            if os.environ.get('CHIAKILISP__REPL_RC_FILE_SHOW_ERRORS'):
                print(exc)
            else:
                print('REPL rc file has errors. Set CHIAKILISP__REPL_RC_FILE_SHOW_ERRORS=1 to see em')
    else:
        with open(rc_file, 'w', encoding='utf-8') as w:
            w.write('(def repl-show-traceback false) ;; set to true to see the exception\' traceback')

    linter_config: dict = {}  # <--- if we could not load linter config from user prefs, use a default

    rc_file = os.path.join(os.environ.get('HOME', os.environ.get('USER')), '.chiakilang-linter-rc.cl')
    if os.path.exists(rc_file):
        try:
            linter_config = require(rc_file, merge=False)  # <- prevent global env from updating there
            if not linter_config.get('Rules'):
                linter_config = {}  # <-- actually, we should manually check linter config correctness
        except (Exception,) as exc:   # pylint: disable=broad-except       # it's okay to this, pylint
            if os.environ.get('CHIAKILISP__LINTER_RC_FILE_SHOW_ERRORS'):
                print(exc)
            else:
                print('Linter rc is broken. Set CHIAKILISP__LINTER_RC_FILE_SHOW_ERRORS=1 to see more')
    else:
        with open(rc_file, 'w', encoding='utf-8') as w:
            w.write(';; this is the ChiakiLisp linter rc-file\n(def Rules ["UnusedGlobalVariables"])')

    if os.path.exists('chiakilisp/corelib/core.cl'):
        require('chiakilisp/corelib/core.cl', merge=True)  # <---------------- load chiakilisp corelib
    else:
        execute(source=pkgutil.get_data('chiakilisp', 'corelib/core.cl').decode('utf-8'), silent=True)

    if len(sys.argv) > 1:
        self: str = sys.argv[0]
        assert len(sys.argv) == 2, f'Usage: {self} [source]'
        file_path: str = sys.argv[1]
        assert os.path.exists(file_path), f'{self}: {file_path}: no such file or directory'
        assert os.path.isfile(file_path) or os.path.islink(file_path), f'{self}: {file_path}: invalid pathnode'
        with open(file_path, 'r', encoding='utf-8') as r:

            if os.environ.get('CHIAKILISP__LINTER_MODE'):
                linter = BuiltinLinter(wood(r.read()), ENVIRONMENT, linter_config)  # <-- initialize the linter
                linter.run()
                linter.fancy_print_report()  # <----------------- this will fancy print generated linter report
                sys.exit(0)  # <----------------------- exit chiakilang after showing report of built-in linter

            if os.environ.get('CHIAKILISP__COMPILER_MODE'):
                generate(r.read(), 'generated.cpp')  # <----------------- generate CPP file named generated.cpp
                sys.exit(0)  # <------------------------------ exit chiakilang after successful code-generation

            execute(r.read(), silent=True)  # <- when silent is set to True, only intentional (prn..) will work
    else:
        print('Press Ctrl+C to cancel input, press Ctrl+D to exit REPL, press Tab to see all global functions')
        repl()
