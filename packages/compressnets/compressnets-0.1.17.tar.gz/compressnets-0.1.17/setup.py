# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['compressnets', 'compressnets.datafiles']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'compressnets',
    'version': '0.1.17',
    'description': 'Package for temporal network data compression',
    'long_description': '# compressnets\n\nCompressnets is a Python package designed to compress high-resolution temporal network data (eg. contact networks)\nto lower resolution, while maintaining important temporal structural features.\n\nCompressnets is designed for taking sequences of static networks (represented as adjacency matrices)\nand compressing them to a user-specified reduced number of adjacency matrices. For example, say you\nhave contact data at the resolution of 20 seconds, over the course of 24 hours, which can be represented\nas 4,320 adjacency matrices. \nYou might wish to compress the data from the original 4,320 adjacency matrices into the best 20 adjacency matrices\nthat best represent the temporal dynamics. The \n`compressnets` package can help you to progressively aggregate the data into the best 20 representative "snapshots" \n(single static network valid for a duration of time). \n\nPre-print with further details on the compression algorithm and theoretical framework is available [on the arXiv](https://arxiv.org/abs/2205.11566).\n\n## Most basic usage\nThis example is just to show how to use the package. In practice, 3 starting snapshots is unrealistic as there wouldn\'t\nbe a need to use an algorithm for compressing 3 snapshots into 2, so this example just demonstrates package usage in a simple way.\nSee below for a usage demo using a built-in sample network.\n\nTo use `compressnets`, install the package via the PyPi (or TestPyPi) index via\n`pip install -i https://test.pypi.org/simple/ compressnets`.\n\nThe core elements of `compressnets` are the objects, `network.TemporalNetwork` and `network.Snapshot`,\nand the algorithm `compression.Compressor.compress(...)`.\n\nFollow along the following example in your own Python workspace with\n```\nfrom compressnets import compression, network\n```\n\nAs an example, create a NumPy array to represent your adjacency matrices:\n```\nsnapshot_1 = [[0, 0, 1],[0, 0, 1],[1, 1, 0]]\nsnapshot_2 = [[0, 1, 1],[1, 0, 1],[1, 1, 0]]\nsnapshot_3 = [[0, 1, 0],[1, 0, 1],[0, 1, 0]]\n```\nThen create a list of `Snapshot` objects from your arrays, equipped with a consecutive start and end time for each:\n```\ninfect_rate = 0.5\nsnapshots = [network.Snapshot(start_time=0, end_time=1, beta=infect_rate, A=snapshot_1),\n             network.Snapshot(start_time=1, end_time=2, beta=infect_rate, A=snapshot_2),\n             network.Snapshot(start_time=2, end_time=3, beta=infect_rate, A=snapshot_3)]\n```\nThen create a `TemporalNetwork` object to contain all of your ordered snapshots:\n```\nyour_temporal_network = network.TemporalNetwork(snapshots)\n```\nUsing the algorithmic compression from our paper [link], you can compress\nthe temporal network into a desired number of compressed snapshots (in this example, 5), by calling on an instance of the static `Compressor` class\n```\nyour_compressed_network_result = compression.Compressor.compress(your_temporal_network,\n                                                          compress_to=2,\n                                                          how=\'optimal\')\n``` \nwhich will return the new `TemporalNetwork` object, and also the total induced error from the snapshots that\nwere selected for compression. The elements can be accessed via a dictionary as\n```\nyour_compressed_network = your_compressed_network_result["compressed_network"]\ntotal_induced_error = your_compressed_network_result["error"]\n```\nTo compress your original network into an even division and aggregation of snapshots,\nnot using our algorithm, you can call `compress` and changing the `how` argument to `even`:\n```\nyour_even_compressed_network_result = compression.Compressor.compress(your_temporal_network,\n                                                          compress_to=2,\n                                                          how=\'even\')\neven_compressed_network = your_even_compressed_network_result["compressed_network"]                                                    \n``` \n\nFrom the resulting compressed `TemporalNetwork` objects, you can now access your snapshots as you\nwould with your original temporal network, by accessing the `snapshots` member via\n```\nyour_new_snapshots = your_compressed_network.snapshots\n```\nfrom which you can access each snapshot\'s new duration, adjacency matrix, start and end times.\n\n## Usage using demo network\n\nFor a more involved demo, make use of the `compressnets.demos` module to access a more complex\ntemporal network without having to create one yourself. Follow the code below in your\nown workspace to use a sample temporal network to compress it, and visualize a system of ODEs over\nthe compressed network vs. the original temporal solution. \n\n```\nfrom compressnets import compression, network, demos, solvers\n\ndemo_network = demos.Sample.get_sample_temporal_network()\ncompressed_optimal = compression.Compressor.compress(my_net, compress_to=4, how=\'optimal\')["compressed_network"]\ncompressed_even = compression.Compressor.compress(my_net, compress_to=4, how=\'even\')["compressed_network"]\n```\nNow you have the resulting compressed temporal networks for the optimal (algorithmic) method and from an even\naggregation method. \n\nTo visualize the new time boundaries of each aggregated snapshot, and compare a full\nSusceptible-Infected disease spread process against the fully temporal network, you can\nutilize the `compressnets.solvers` module to solve a system of ODEs and plot the resulting figure:\n\n```\n## Creating and solving a model with the original temporal network\n\nN = demo_network.snapshots[0].N\nbeta = demo_network.snapshots[0].beta\nmodel = solvers.TemporalSIModel({\'beta\': beta}, np.array([1/N for _ in range(N)]),\n                                demo_network.snapshots[demo_network.length-1].end_time,\n                                demo_network)\nsoln = model.solve_model()\nsmooth_soln = model.smooth_solution(soln)\nplt.plot(smooth_soln[0], smooth_soln[1], color=\'k\', label=\'Temporal solution\')\nplt.vlines(list(demo_network.get_time_network_map().keys()), ymin=0, ymax=N/3, ls=\'-\',\n          lw=0.5, alpha=1.0, color=\'k\')\n\n\n## Creating and solving a model with the algorithmically compressed temporal network\n\nN = compressed_optimal.snapshots[0].N\nbeta = compressed_optimal.snapshots[0].beta\nmodel = solvers.TemporalSIModel({\'beta\': beta}, np.array([1/N for _ in range(N)]),\n                                compressed_optimal.snapshots[compressed_optimal.length-1].end_time,\n                                compressed_optimal)\nsoln = model.solve_model()\nsmooth_soln = model.smooth_solution(soln)\nplt.plot(smooth_soln[0], smooth_soln[1], color=\'b\', label=\'Optimal compressed\')\nplt.vlines(list(compressed_optimal.get_time_network_map().keys()), ymin=N/3, ymax=2*N/3, ls=\'-\',\n          lw=0.5, alpha=1.0, color=\'b\')\n\n\n## Creating and solving a model with the evenly compressed temporal network\n\nN = compressed_even.snapshots[0].N\nbeta = compressed_even.snapshots[0].beta\nmodel = solvers.TemporalSIModel({\'beta\': beta}, np.array([1/N for _ in range(N)]),\n                                compressed_even.snapshots[compressed_even.length-1].end_time,\n                                compressed_even)\nsoln = model.solve_model()\nsmooth_soln = model.smooth_solution(soln)\nplt.plot(smooth_soln[0], smooth_soln[1], color=\'r\', label=\'Even compressed\')\nplt.vlines(list(compressed_even.get_time_network_map().keys()), ymin=2*N/3, ymax=N, ls=\'-\',\n          lw=0.5, alpha=1.0, color=\'r\')\n\nplt.ylabel(\'Number infected\')\nplt.xlabel(\'Time\')\nplt.legend()\nplt.show()\n```\n\n\n![](compressnets/datafiles/sample_fig.png)\n\nOutput figure from the sample code above using the provided demo temporal network.\nThe original temporal network has 50 snapshots and is compressed down to 4 snapshots.\nIn blue, you see the resulting temporal boundaries of the 4 snapshots compressed using our\nalgorithm. In red, you see the resulting temporal boundaries of the 4 snapshots compressed\ninto even-size aggregate matrices. The time series represent an SI epidemic process over the\n3 versions of the network.\n\n## Citation\n\nIf you use this package, please name your use of this package as well as the original \npaper on the framework, as \n\nAllen, Andrea J. and Moore, Cristopher and HÃ©bert-Dufresne, Laurent.\nA network compression approach for quantifying the importance of temporal contact chronology.\nPreprint at https://arxiv.org/abs/2205.11566 (2022).\n\n\n\n',
    'author': 'Andrea Allen',
    'author_email': 'andrea2allen@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/andrea-allen/compressnets',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<3.11',
}


setup(**setup_kwargs)
