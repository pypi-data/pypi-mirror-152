#!/usr/bin/env python3

# So, this is the new distfile spider. What I want to do is to have this thing be able to load
# metadata JSON and then check with mongodb to ensure files are in fastpull, and if not, run through
# the JSON and try to grab missing files, and generate a report. Then exit. So it isn't a long-
# running daemon -- it will run for as long as needed to do its thing.

import logging
import os
import sys
from argparse import ArgumentParser
from collections import defaultdict
from concurrent.futures.thread import ThreadPoolExecutor
from datetime import datetime
from multiprocessing import cpu_count
import asyncio

from subpop.hub import Hub


hub = Hub()

import dyne.org.funtoo.metatools.pkgtools as pkgtools
import threading

master_lock = threading.Lock()
running_set = set()


async def do_distfile_fetch(distinct_key, distinct_file_list):
	"""
	This function takes a "file" which is the JSON structure from a kit-cache JSON that describes a file associated
	with a package. It will then see if the file is in the fastpull DB. If not, it will ensure the file is fetched,
	which will then cause it to be inserted into the fastpull DB.
	"""
	with master_lock:
		running_set.add(distinct_key)
	name, sha512, size = distinct_key

	all_src_uris = set()
	refs = []
	ffile = None
	for file, datums in distinct_file_list:
		if ffile is None:
			# grab first file for later use
			ffile = file
		all_src_uris = all_src_uris | set(file["src_uri"])
		refs.append({"kit": datums["kit"], "catpkg": datums["catpkg"]})

	src_uris = merge.parent.expand_uris(list(all_src_uris))
	fp_path = merge.parent.get_disk_path(sha512)
	keep_going = True
	if not os.path.exists(fp_path):

		# TODO: the file could still be locally fetched. So we may still be able to inject? Likely just a weird corner case:
		if not len(src_uris):
			keep_going = False
		else:
			try:
				print(src_uris[0])
				a = pkgtools.ebuild.Artifact(url=src_uris[0], final_name=name, expect={"sha512": sha512, "size": size})
				await a.inject_into_fastpull()
				print("done", src_uris[0])
			except pkgtools.ebuild.DigestFailure as af:
				logging.error(af)
				keep_going = False

	with master_lock:
		running_set.remove(distinct_key)

	if not keep_going:
		return

	existing = merge.model.FASTPULL.find_one({"filename": name, "hashes.sha512": sha512})
	if existing:
		sys.stdout.write("_")
		sys.stdout.flush()
	else:
		# store size inside hashes
		hashes = ffile["hashes"].copy()
		hashes["size"] = size
		db_entry = {}
		db_entry["fetched_on"] = datetime.utcnow()
		db_entry["filename"] = name
		db_entry["hashes"] = ffile["hashes"]
		db_entry["src_uri"] = src_uris
		db_entry["refs"] = refs
		merge.model.FASTPULL.insert_one(db_entry)
		sys.stdout.write("+")
		sys.stdout.flush()


async def status_update():
	while True:
		with master_lock:
			print("***********")
			print(running_set)
		await asyncio.sleep(5)


async def main_thread():
	asyncio.create_task(status_update())
	global exceptions
	mk_json = merge.metadata.load_json(args.infile)
	if mk_json is None:
		print(f"Skipping {args.infile} due to old/invalid JSON format.")
		return
	futures = []
	distinct_files = defaultdict(list)
	for atom, datums in mk_json["atoms"].items():
		if "files" in datums:
			for file in datums["files"]:
				if "hashes" in file and "sha512" in file["hashes"]:
					distinct_key = (file["name"], file["hashes"]["sha512"], int(file["size"]))
					distinct_files[distinct_key].append((file, datums))

	with ThreadPoolExecutor(max_workers=cpu_count()) as threadpool:
		for distinct_key, distinct_file_list in distinct_files.items():
			future = hub.LOOP.run_in_executor(
				threadpool, pkgtools.thread.run_async_adapter, do_distfile_fetch, distinct_key, distinct_file_list
			)
			futures.append(future)
		results, exceptions = await pkgtools.autogen.gather_pending_tasks(futures, throw=True)


if __name__ == "__main__":

	ap = ArgumentParser()
	ap.add_argument("infile")
	args = ap.parse_args()

	# We need kit-fixups available so we can grab the thirdpartymirrors file from it.

	hub.LOOP.run_until_complete(main_thread())

# vim: ts=4 sw=4 noet
