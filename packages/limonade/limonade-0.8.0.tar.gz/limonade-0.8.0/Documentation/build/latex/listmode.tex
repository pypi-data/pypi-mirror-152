%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[noconfigs,british]{babel} 
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{listmode}
\date{Jun 15, 2021}
\release{0.5.0}
\author{Timo Hilden}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
This manual is divided into User manual and function reference.


\chapter{Introduction}
\label{\detokenize{manual/manual:introduction}}\label{\detokenize{manual/manual::doc}}

\section{What is Listmode}
\label{\detokenize{manual/manual:what-is-listmode}}
\sphinxAtStartPar
Listmode is a library built around a single Data class and a lot of helper functions and classes.
The objective of Listmode is to simplify handling of listmode data from different sources. Ideally
all interaction with the library is either via the data class or the plotter function. Data can be
created by the streamer class. All details of the data are be defined by configuration of the
detector and the plot using configuration files written in json.

\sphinxAtStartPar
The data can be retrieved and histogrammed using powerful selection tools in the plot module.
These include selecting events by time interval, energy gates in (anti)coincident channels or
even gates in some extra data, such as coordinate information. Gates can also be defined as
polygonal 2d gates between any two pieces of data.

\sphinxAtStartPar
Listmode data tends to grow big. A single dataset is easily several million events long. Storing
all that data in memory is not efficient and in some cases not even possible. All data
operations in Listmode are processed in chunks. The data itself is stored in hard drive as
binary format files and only small chunk is read at a time. All data is immutable, in the sense
that the datafiles are never modified. Any change in data needs to be streamed into a new set of
datafiles.


\section{How to use Listmode}
\label{\detokenize{manual/manual:how-to-use-listmode}}
\sphinxAtStartPar
The most important thing for user is to understand the structure and use of the configuration
files and the logic of the flow of data in the storage and plotting pipelines.


\section{What is data?}
\label{\detokenize{manual/manual:what-is-data}}
\sphinxAtStartPar
Data is timestamps. Timestamps are handled in a special way throughout the library. Every single
event has a timestamp. Timestamps are used to index the events and are the basis of the hashing
system used to speed up searches from long (multi\sphinxhyphen{}million event) datasets. Time interval of any
data operation needs to be defined before anything else. The start and stop indices in the time
slice are retrieved and the data loaded in chunks and set forward in the pipeline.

\sphinxAtStartPar
The data associated with the timestamp includes energy information for the channels that belong
to the event. At the moment the energy information is always present for every channel of the detector. Event can hold
other data in addition to energy information. For example coordinate information, signal rise time
value or a pile\sphinxhyphen{}up bit can be recorded by the detector and can be included as part of an event. This
extra data is always associated with a channel of the detector.


\section{The flow of data}
\label{\detokenize{manual/manual:the-flow-of-data}}
\sphinxAtStartPar
The most typical data operation is a plot. A plot is defined by plot configuration, a dictionary
or a file, which defines what plot class is instanced by the plotter function. Plot class loads
data in chunks, using the get\_data\_block method of the data class. It then makes the gate
selection defined in configuration using coincidence\_mask function and feeds the selected data to
the filter which calculates a histogram of the data block. Plot class combines all the chunk
histograms into a master histogram which is then returned.

\sphinxAtStartPar
Normally all this is done automatically by the plotter function but can as well be done manually
using the data (and plot) class and selection function.


\section{How to start}
\label{\detokenize{manual/manual:how-to-start}}
\sphinxAtStartPar
An overview of the different configuration files can be found in the section {\hyperref[\detokenize{manual/configuration:configuration}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration files}}}}.


\chapter{Configuration files}
\label{\detokenize{manual/configuration:configuration-files}}\label{\detokenize{manual/configuration:configuration}}\label{\detokenize{manual/configuration::doc}}

\section{Detector configuration}
\label{\detokenize{manual/configuration:detector-configuration}}\begin{quote}\begin{description}
\item[{name}] \leavevmode
\sphinxAtStartPar
Name of the detector.

\item[{data\_type}] \leavevmode
\sphinxAtStartPar
Defines the raw data loader. Built\sphinxhyphen{}in options are:
\begin{quote}\begin{description}
\item[{standard}] \leavevmode
\sphinxAtStartPar
The data mode native to Listmode. All other data is converted to native
format before parsing

\item[{caen}] \leavevmode
\sphinxAtStartPar
The data file saved by Caen MC2 program with extra data set on.

\item[{panda}] \leavevmode
\sphinxAtStartPar
For PANDA data files.

\item[{ortec}] \leavevmode
\sphinxAtStartPar
For data files saved with Ortec Maestro program.

\end{description}\end{quote}

\item[{extension}] \leavevmode
\sphinxAtStartPar
The extension of the raw data files. Extension can include wildcard characters.

\item[{daq\_type}] \leavevmode
\sphinxAtStartPar
Might be redundant.

\item[{coinc\_win}] \leavevmode
\sphinxAtStartPar
Coincidence window length in nanoseconds. This is the max time interval between two
counts so that they will be built into a single event.

\item[{sample\_ns}] \leavevmode
\sphinxAtStartPar
Size of the time tick of the detector in ns.

\item[{readout\_cfg}] \leavevmode
\sphinxAtStartPar
Optional, will probably be moved to another config file. Defines readout electronics
specific configuration file used for daq.

\item[{cal\_name}] \leavevmode
\sphinxAtStartPar
Name of the energy calibration file for the detector. Located in config/ecal directory.

\item[{effcal}] \leavevmode
\sphinxAtStartPar
Name of the gamma efficiency calibration file. Located in config/effcal directory.

\item[{ch\_cfg}] \leavevmode
\sphinxAtStartPar
List of ch\_config dictionaries. One per channel.

\item[{events}] \leavevmode
\sphinxAtStartPar
Definition of energy information. A data\_info dictionary.

\item[{extras}] \leavevmode
\sphinxAtStartPar
Definition of any extra data. A list of data\_info dictionaries.

\item[{latency}] \leavevmode
\sphinxAtStartPar
Latency values in ns. A list of values, one per channel, which are added to channel
timestamps before searching for coincidences.

\item[{histo\_size}] \leavevmode
\sphinxAtStartPar
Optional, will probably be moved to another config file. Defines the number of bins in
the histogram returned by daq.

\item[{ch\_list}] \leavevmode
\sphinxAtStartPar
List of channels with indices to ‘ch\_cfg’ list. Defines the order (and number) of
channels in the output. Functionality of this may be changed in the future.

\end{description}\end{quote}


\subsection{ch\_config}
\label{\detokenize{manual/configuration:ch-config}}\begin{quote}\begin{description}
\item[{name}] \leavevmode
\sphinxAtStartPar
Name of the channel. Will appear in title and legend of plots.

\item[{cfg\_file}] \leavevmode
\sphinxAtStartPar
Optional, will probably be moved to another config file. Defines readout channel
specific configuration file used for daq.

\item[{pdeadtime}] \leavevmode
\sphinxAtStartPar
Dead time of a single pulse in the channel. This value will be used to calculate
estimated dead time in data formats where hardware calculated dead time does not
exist (Caen) or where it cannot be fully trusted (Caen). This value includes the
rise time, flat top and any trigger holdoff values and needs to be corrected whenever
configuration is changed.

\end{description}\end{quote}


\subsection{data\_info}
\label{\detokenize{manual/configuration:data-info}}\begin{quote}\begin{description}
\item[{name}] \leavevmode
\sphinxAtStartPar
the name of the data. Energy information is always ‘energy’ and value in this field is
ignored.

\item[{type}] \leavevmode
\sphinxAtStartPar
Numpy type string describing the data format in the binary file. For energy the default
is ‘i2’ for signed 16\sphinxhyphen{}bit integer. Extras don’t have defaults and type must be defined.

\item[{ch\_mask}] \leavevmode
\sphinxAtStartPar
Defines which energy channels have this extra associated with. Given as a list of zeros
and ones. Energy data is always one column per channel and this key is ignored. Default
is all channels.

\item[{aggregate}] \leavevmode
\sphinxAtStartPar
Defines how the data is combined or created in the event parser. Normally extras are just
read from channel files and combined as events in the event construction. Some builtin
extra data types are created while the events are built and exist only as final data.
\begin{quote}\begin{description}
\item[{col}] \leavevmode
\sphinxAtStartPar
Data is saved as columns in a matrix with number of columns defined by ‘ch\_mask’.

\item[{bit}] \leavevmode
\sphinxAtStartPar
Bit mask with a single bit ber channel.

\item[{latency}] \leavevmode
\sphinxAtStartPar
\sphinxstyleemphasis{Builtin extra.} The time difference between counts in different channels. Needs
additional key ‘main’ to define the channel that is compared against the others.
Output is always (number of channels \sphinxhyphen{} 1) columns.

\item[{multihit}] \leavevmode
\sphinxAtStartPar
\sphinxstyleemphasis{Builtin extra.} A bit mask with bit set on a channel that received multiple
hits per event.

\end{description}\end{quote}

\item[{multi}] \leavevmode
\sphinxAtStartPar
Defines what happens if two or more hits are detected in a single channel within a single
event (inside the coincidence window). Valid values are:
\begin{quote}\begin{description}
\item[{sum}] \leavevmode
\sphinxAtStartPar
Sum of the values

\item[{max}] \leavevmode
\sphinxAtStartPar
Maximum of the values

\item[{min}] \leavevmode
\sphinxAtStartPar
Minimum of the values

\item[{mean}] \leavevmode
\sphinxAtStartPar
Mean of the values

\item[{kill}] \leavevmode
\sphinxAtStartPar
The event is discarded

\item[{max\_e}] \leavevmode
\sphinxAtStartPar
Value in the hit where energy is largest

\end{description}\end{quote}

\item[{raw unit}] \leavevmode
\sphinxAtStartPar
String that is used as unit for uncalibrated data. Default is ‘ch’.

\item[{unit}] \leavevmode
\sphinxAtStartPar
String that is used for calibrated data. Default for energy is ‘KeV’.

\item[{empty\_val}] \leavevmode
\sphinxAtStartPar
Value given to channels that don’t have information. Default for energy is \sphinxhyphen{}1, for all
other extras the default is 0. Latency extra has this set to smallest value of the datatype
and ignores this parameter.

\item[{num\_col}] \leavevmode
\sphinxAtStartPar
Number of columns in the parsed data matrix. It is automatically calculated. For energy it is the number
of channels, for extras this value is calculated based on ‘ch\_mask’ or defined by the type of inbuilt
extra. It is used by the data loader.

\item[{main}] \leavevmode
\sphinxAtStartPar
‘main’ is used by the ‘latency’ aggregate to single out which channel time is compared against
the others.

\end{description}\end{quote}


\section{Plot configuration}
\label{\detokenize{manual/configuration:plot-configuration}}
\sphinxAtStartPar
Plot configuration defines the data in the plot as well as the plotting parameters, such as labels, scales etc.
Only one plot can be defined per Plot object. However multiple plots can be stacked into the plot\_cfg list of the plot
configuration. If all of the plots are 1d and have same axes they can be plotted into a single figure. Creating figures
and handling how to stack plots into figures should be done explicitly by the user. Two Plot instances can be compared
for equality. The result is True only if they can be shown in the same axes. The Plot class uses only the information
in plot\_cfg and the name.
\begin{quote}\begin{description}
\item[{name}] \leavevmode
\sphinxAtStartPar
Name of the canvas. Will be visible in the title of the plot.

\item[{plot\_cfg}] \leavevmode
\sphinxAtStartPar
List defining all plots in the configuration file. If multi plot configuration is given the index of the
plot has to be set by plot\_idx keyword on initialization of the Plot object. First plot in this list is
configured if index is not given. A plot is defined by its name, axes and gates:
\begin{quote}\begin{description}
\item[{plot\_name}] \leavevmode
\sphinxAtStartPar
Name for the individual plot that helps to understand the content of the plot. Will be
visible in the legend of 1d plots and as the label of the colorbar in 2d plots.

\item[{axes}] \leavevmode
\sphinxAtStartPar
An axis info dictionary defining the x\sphinxhyphen{}axis of the plot or a list defining two
axis\_infos for a 2d plot.

\item[{gates}] \leavevmode
\sphinxAtStartPar
A list of gate\_info dictionaries. All gates in this list are applied in AND mode.

\end{description}\end{quote}

\end{description}\end{quote}

\sphinxAtStartPar
The rest of the plot configuration is not used by listmode library at all.
\begin{quote}\begin{description}
\item[{xscale}] \leavevmode
\sphinxAtStartPar
Defines whether x axis of a plot is logarithmic (“log”) or linear (“linear”,
default).

\item[{yscale}] \leavevmode
\sphinxAtStartPar
Defines whether x axis of a plot is logarithmic (“log”) or linear (“linear”,
default).

\item[{zscale}] \leavevmode
\sphinxAtStartPar
Defines whether z axis (colorbar) of a 2d\sphinxhyphen{}plot is logarithmic (“log”) or linear
(“linear”, default)

\item[{reverse\_x\_axis}] \leavevmode
\sphinxAtStartPar
Optional string that defines whether x\sphinxhyphen{}axis is reversed in a plot.

\item[{reverse\_y\_axis}] \leavevmode
\sphinxAtStartPar
Optional string that defines whether y\sphinxhyphen{}axis is reversed in a plot.

\end{description}\end{quote}


\subsection{axis\_info}
\label{\detokenize{manual/configuration:axis-info}}
\sphinxAtStartPar
A dictionary defining each data axis of the plot:
:channel:       The channel to plot. Note that some extra data have different number of channels. Note also that this
\begin{quote}

\sphinxAtStartPar
defines the name printed to legend for 1d plots, also for time axes. It should match the gate used
for selecting the data (if applicable) for time plots.
\end{quote}
\begin{quote}\begin{description}
\item[{data}] \leavevmode
\sphinxAtStartPar
A string defining the name of the data to be plotted on this axis. This can be “time”, “energy” or any of
the extras.

\item[{bin\_width}] \leavevmode
\sphinxAtStartPar
For normal data this is an integer width of bin in raw units. Note, for time axis this is in timebase
units instead and fractional bin widths can be used.

\item[{range}] \leavevmode
\sphinxAtStartPar
A two item list defining lower and upper limits in calibrated units. Ignored with time axes.

\item[{timebase}] \leavevmode
\sphinxAtStartPar
Only relevant for time axes. A string defining the base unit for time axes.
(“ns”, “us”, “ms”, “s”, “m”, “h” and “d”).

\end{description}\end{quote}


\subsection{gate\_info}
\label{\detokenize{manual/configuration:gate-info}}
\sphinxAtStartPar
A dictionary defining a gate
:channel:       The channel to gate with.
\begin{quote}\begin{description}
\item[{data}] \leavevmode
\sphinxAtStartPar
A string defining the name of the data to be gated with. This can be “time”, “energy” or any of the extras.

\item[{range}] \leavevmode
\sphinxAtStartPar
A nested list defining the ranges that are used for the gate. Each range is a list of start and stop values.
The ranges are defined in calibrated units. Bitmask type data ignores range. An event is in range if
True and not if False.

\item[{coinc}] \leavevmode
\sphinxAtStartPar
An integer defining whether the gate is anticoincident (negative integer), coincident (positive
integer) or null (zero). Coincident gate only passes events with data value in that channel contained
within the gate range, anticoincident passes if not. A zero defines a null gate. It will not cause
filtering of the data \sphinxhyphen{} it is not processed at all. Use null gates to switch off gates quickly.

\end{description}\end{quote}


\chapter{Reference}
\label{\detokenize{autodocs/reference:reference}}\label{\detokenize{autodocs/reference::doc}}
\sphinxAtStartPar
This is the basic stuff about the lib, right?


\section{Data}
\label{\detokenize{autodocs/data:module-listmode.data}}\label{\detokenize{autodocs/data:data}}\label{\detokenize{autodocs/data::doc}}\index{module@\spxentry{module}!listmode.data@\spxentry{listmode.data}}\index{listmode.data@\spxentry{listmode.data}!module@\spxentry{module}}\index{BitProcessor (class in listmode.data)@\spxentry{BitProcessor}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.BitProcessor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{BitProcessor}}}{\emph{\DUrole{n}{info}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{autodocs/data:listmode.data.ColProcessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{listmode.data.ColProcessor}}}}}
\index{process() (listmode.data.BitProcessor method)@\spxentry{process()}\spxextra{listmode.data.BitProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.BitProcessor.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{\emph{\DUrole{n}{in\_list}}, \emph{\DUrole{n}{out}}, \emph{\DUrole{n}{t\_front}}, \emph{\DUrole{n}{ev\_count}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} list of data\_dicts, one per channel

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out}} \textendash{} list of initialized output data arrays

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_front}} \textendash{} current position in data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} number of hits per channel in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_num}} \textendash{} number of hits per channel in the event

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColProcessor (class in listmode.data)@\spxentry{ColProcessor}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.ColProcessor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{ColProcessor}}}{\emph{\DUrole{n}{info}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Simple class for aggregating data in event building.
It is initialized with the data info (like in extras definition) including
what happens when multiple events are found within the same time window.

\sphinxAtStartPar
The process method is given input events, channel mask and output data structure.
Output data is modified in\sphinxhyphen{}place. Each instance of a class is only updating its own
part of the data (energy, timing, coord, etc.) and is supposed to be run in a pipeline
for every event.
\index{process() (listmode.data.ColProcessor method)@\spxentry{process()}\spxextra{listmode.data.ColProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.ColProcessor.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{\emph{\DUrole{n}{in\_list}}, \emph{\DUrole{n}{out}}, \emph{\DUrole{n}{t\_front}}, \emph{\DUrole{n}{ev\_count}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} list of data\_dicts, one per channel

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out}} \textendash{} list of initialized output data arrays

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_front}} \textendash{} current position in data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} number of hits per channel in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_num}} \textendash{} number of hits per channel in the event

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Data (class in listmode.data)@\spxentry{Data}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{Data}}}{\emph{\DUrole{n}{config}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Sort of generic data class, with plug\sphinxhyphen{}in dataloader for vendor specific raw data
and extra data items configurable via configuration file.

\sphinxAtStartPar
Timestamp is always present in all kinds of data. It stores the event time in nanoseconds since the start
of the data. It is always 64\sphinxhyphen{}bit unsigned integer and is handled in a special way by listmode. All other
data is defined by info\sphinxhyphen{}dictionaries that are of the form:
info\_dict = \{“name”: “some\_data”,
\begin{quote}

\sphinxAtStartPar
“type”: “u1”,
“num\_col”: 2,
“aggregate”: “col”,
“ch\_mask”: {[}1, 1, 0, 0{]},
“multi”: “mean”\}
\end{quote}

\sphinxAtStartPar
Data is held in a data dictionary, with data name as key and memmap of the data as the value. (Currently
the data is also held as members with same name as the data for backward compatibility using \_update method).

\sphinxAtStartPar
All data is stored in numpy arrays in the data dict. The data dict always contains time\_vec and data\_mat: time
and energy information of events. data\_mat is defined by ‘events’ info dict in the configuration file.

\sphinxAtStartPar
Data dict can also contain extra data, defined by ‘extras’ list of info dicts in the configuration file.
Few types of extras are hardcoded into Listmode and are handled in a special way if they are present:
coord:  coordinate information. Correspondence of channels to coordinate columns is given by
\begin{quote}

\sphinxAtStartPar
config.det{[}‘coordinates’{]}. This is used for data selection and plots.
\end{quote}
\begin{description}
\item[{latency:timing information. Each column is the time difference between ‘main’ channel and other channels in the}] \leavevmode
\sphinxAtStartPar
event. Used to tune the latency and coincidence window.

\item[{multihit: A flag that is raised if a channel has several hits per event. A type of nondestuctive pileup. The}] \leavevmode
\sphinxAtStartPar
energy value of a multihit event is calculated using a function defined by the ‘multi’ keyword.

\end{description}

\sphinxAtStartPar
All other extras are just carried along with the data and can be plotted (not quite yet) or used for event
selection (not there either).
\index{get\_data\_block() (listmode.data.Data method)@\spxentry{get\_data\_block()}\spxextra{listmode.data.Data method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Data.get_data_block}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_data\_block}}}{\emph{\DUrole{n}{t\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Get data and time vectors, but processed in chunks of 1M events to save memory. Optionally, define a slice in
time. The method should be called in a loop to read everything. All data including extras is returned.

\sphinxAtStartPar
Last return value isdata indicates if there is more data to come. On a False the loop should be stopped, but
the last data is still valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_slice}} \textendash{} A tuple of start and stp times in nanoseconds. Full data is set to be read if this is None. The
time slice should never be changed while reading the data in a loop.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A tuple of (data\_dict, isdata) for current chunk.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dead\_time() (listmode.data.Data method)@\spxentry{get\_dead\_time()}\spxextra{listmode.data.Data method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Data.get_dead_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_dead\_time}}}{\emph{\DUrole{n}{t\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Get dead time for the data or a time\_slice of data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_slice}} \textendash{} a tuple of start and stop times in nanoseconds. Full dead time is retrieved if this is set to
None.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The dead times in {[}s{]} for all channels as a vector of floats.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_end\_time() (listmode.data.Data method)@\spxentry{get\_end\_time()}\spxextra{listmode.data.Data method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Data.get_end_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_end\_time}}}{}{}
\end{fulllineitems}

\index{load\_data() (listmode.data.Data method)@\spxentry{load\_data()}\spxextra{listmode.data.Data method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Data.load_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_data}}}{\emph{\DUrole{n}{data\_path\_str}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{reset}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Loads data preferably from event mode .dat files. If this fails, then channel data is searched for. (Channel
data may be saved as intermediary step when doing slow conversion from other data formats.) Otherwise
\_read\_raw\_data method is called. Native format has no raw data and will fail.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_path\_str}} \textendash{} Path to data directory. It has to be either a string or a pathlib Path object.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Optional name, if data file does not share the same base\_name as the directory.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reset}} (\sphinxstyleliteralemphasis{\sphinxupquote{Bool}}) \textendash{} The raw data parsing can be forced with reset=True.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{EventBuilder (class in listmode.data)@\spxentry{EventBuilder}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.EventBuilder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{EventBuilder}}}{\emph{\DUrole{n}{num\_ch}}, \emph{\DUrole{n}{coinc\_win}}, \emph{\DUrole{n}{latency}}, \emph{\DUrole{n}{extras}}, \emph{\DUrole{n}{event\_info}}, \emph{\DUrole{n}{max\_datasize}\DUrole{o}{=}\DUrole{default_value}{8192}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Painful way of walking through the data and trying to build events
by seeking coincidences between channel times.

\sphinxAtStartPar
Ideally works on shortish arrays of data returned by the digitizer, but should manage big savefiles in chunks.
\index{run\_batch() (listmode.data.EventBuilder method)@\spxentry{run\_batch()}\spxextra{listmode.data.EventBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.EventBuilder.run_batch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_batch}}}{\emph{\DUrole{n}{data\_dict}}, \emph{\DUrole{n}{timing\_list}}}{}
\sphinxAtStartPar
The time front is a list of the lowest unbuilt indices for each channel.
(The t0 is the times, E0 the energies)
The channel which has lowest time in the front is put to an event
and if other channels in the front have time within the window, then
they are included. The front is incremented for all the channels that
were included and the iteration is started again.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_dict}} \textendash{} list of data\_dicts for each channel

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timing\_list}} \textendash{} list holding timing information for each channel

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
data\_dict, timing\_data

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LatencyProcessor (class in listmode.data)@\spxentry{LatencyProcessor}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.LatencyProcessor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{LatencyProcessor}}}{\emph{\DUrole{n}{info}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{autodocs/data:listmode.data.ColProcessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{listmode.data.ColProcessor}}}}}

\sphinxAtStartPar
LatencyProcessor is a specialized processor used to visualize the timing properties of the input data. Each
output column is equal to time difference between event in main channel and event in each other channel
(so output of main channel is always zeros) calculated from latency corrected time data. Smallest possible value is
returned if there was no coincidence between the channels. All channels should show zero\sphinxhyphen{}centered distributions
in a properly tuned detector. Width of the distributions will show how big coincidence window is needed.
\index{process() (listmode.data.LatencyProcessor method)@\spxentry{process()}\spxextra{listmode.data.LatencyProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.LatencyProcessor.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{\emph{\DUrole{n}{in\_list}}, \emph{\DUrole{n}{out}}, \emph{\DUrole{n}{t\_front}}, \emph{\DUrole{n}{ev\_count}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} list of data\_dicts, one per channel

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out}} \textendash{} list of initialized output data arrays

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_front}} \textendash{} current position in data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} number of hits per channel in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_num}} \textendash{} number of hits per channel in the event

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Metadata (class in listmode.data)@\spxentry{Metadata}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{Metadata}}}{\emph{\DUrole{n}{parent}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Metadata is responsible for the saving, loading and generation of metadata within data.

\sphinxAtStartPar
Under normal circumstances the metadata is present in a json file, and is loaded by the metadata class. If,
however, metadata is missing or needs to be changed the metadata class provides methods for updating, validating
and saving the changes.
\index{calculate() (listmode.data.Metadata method)@\spxentry{calculate()}\spxextra{listmode.data.Metadata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.calculate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate}}}{}{}
\sphinxAtStartPar
Generates metadata from parent data and members. Calculate should not touch values that are set by the loader.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{counts (listmode.data.Metadata property)@\spxentry{counts}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.counts}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{counts}}}
\end{fulllineitems}

\index{events (listmode.data.Metadata property)@\spxentry{events}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.events}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{events}}}
\end{fulllineitems}

\index{get() (listmode.data.Metadata method)@\spxentry{get()}\spxextra{listmode.data.Metadata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.get}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{channel}}}{}
\sphinxAtStartPar
Get a metadata item that is not one of the properties. This is simply wrapping the dict indexing.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} keyword to get

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} \textendash{} channel

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
value

\end{description}\end{quote}

\end{fulllineitems}

\index{input\_counts (listmode.data.Metadata property)@\spxentry{input\_counts}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.input_counts}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{input\_counts}}}
\end{fulllineitems}

\index{load() (listmode.data.Metadata method)@\spxentry{load()}\spxextra{listmode.data.Metadata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{}{}
\sphinxAtStartPar
Loads metadata from json files. If incomplete metadata is loaded it is updated from the data.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{name (listmode.data.Metadata property)@\spxentry{name}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.name}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{name}}}
\end{fulllineitems}

\index{notes (listmode.data.Metadata property)@\spxentry{notes}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.notes}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{notes}}}
\end{fulllineitems}

\index{run\_id (listmode.data.Metadata property)@\spxentry{run\_id}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.run_id}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{run\_id}}}
\end{fulllineitems}

\index{save() (listmode.data.Metadata method)@\spxentry{save()}\spxextra{listmode.data.Metadata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{}{}
\sphinxAtStartPar
Save metadata back to json.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (listmode.data.Metadata method)@\spxentry{set()}\spxextra{listmode.data.Metadata method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.set}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{value}}, \emph{\DUrole{n}{channel}}}{}
\sphinxAtStartPar
Set a metadata item for one or all channels. For example some sample related information can be retrieved from
database and added to metadata after the data is created. This method exists to give easy access to
metadata for the loader functions of vendor specific data. This method should not be used to set the
minimal metadata handled by the properties of Metadata class. ListModeMetadataSetError is raised if even tried.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} Key to \_run\_data dict

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} A value to set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} \textendash{} Channel to modify. If ch is less than 0, then all channels are updated.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{start (listmode.data.Metadata property)@\spxentry{start}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.start}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{start}}}
\end{fulllineitems}

\index{stop (listmode.data.Metadata property)@\spxentry{stop}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.stop}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{stop}}}
\end{fulllineitems}

\index{total\_time (listmode.data.Metadata property)@\spxentry{total\_time}\spxextra{listmode.data.Metadata property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.Metadata.total_time}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{total\_time}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MultiHitProcessor (class in listmode.data)@\spxentry{MultiHitProcessor}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.MultiHitProcessor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{MultiHitProcessor}}}{\emph{\DUrole{n}{info}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{autodocs/data:listmode.data.BitProcessor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{listmode.data.BitProcessor}}}}}

\sphinxAtStartPar
MultiHitProcessor calculates a bitmask where channels with multiple hits per event are
set to 1.
\index{process() (listmode.data.MultiHitProcessor method)@\spxentry{process()}\spxextra{listmode.data.MultiHitProcessor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.MultiHitProcessor.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{\emph{\DUrole{n}{in\_list}}, \emph{\DUrole{n}{out}}, \emph{\DUrole{n}{t\_front}}, \emph{\DUrole{n}{ev\_count}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} list of data\_dicts, one per channel

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{out}} \textendash{} list of initialized output data arrays

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_front}} \textendash{} current position in data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} number of hits per channel in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_num}} \textendash{} number of hits per channel in the event

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StreamData (class in listmode.data)@\spxentry{StreamData}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.StreamData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{StreamData}}}{\emph{\DUrole{n}{path}}, \emph{\DUrole{n}{data\_name}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}event\textquotesingle{}}}, \emph{\DUrole{n}{raw}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{channels}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{extra\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Stream\_data is a manager that pushes list mode data into disk as it comes available. Every kind
of data (time + energy for channel, time + energy matrix for events, timing data and extra data) needs to have its
own streamer.

\sphinxAtStartPar
Channel mode data is stored as raw binary files, with one file holding time (uint64), one the energy (uint16).
Note: there is no reason to save data in channel mode after latency and coincidence window are set.

\sphinxAtStartPar
Event data is stored as raw binary with timestamps (uint64), energy matrix (uint16 x num\_ch)

\sphinxAtStartPar
Timing data is a row of timing info (uint32 idx + 2xuint32 x num\_ch).

\sphinxAtStartPar
Extra data can can be given via the extras dictionary (keys: ‘name’, ‘type’, ‘num\_col’). Extras can include pile\sphinxhyphen{}up
flags (Type x num\_ch) or coordinates (Type x N), where N is number of coordinates.
\index{close() (listmode.data.StreamData method)@\spxentry{close()}\spxextra{listmode.data.StreamData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.StreamData.close}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{close}}}{}{}
\end{fulllineitems}

\index{new\_files() (listmode.data.StreamData method)@\spxentry{new\_files()}\spxextra{listmode.data.StreamData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.StreamData.new_files}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{new\_files}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{TimeCache (class in listmode.data)@\spxentry{TimeCache}\spxextra{class in listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{TimeCache}}}{\emph{\DUrole{n}{parent}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
TimeCache controls timing data and provides dead/live time of the detector plus maintains lists of index \sphinxhyphen{} time
pairs of the time information insertions times so that quick retrieval of time periods is possible. Each interval
holds variable amount of events. Because both indices and timestamps are monotonously increasing, they can both be
used to find intervals from the data.
The timing datafile is saved with data and should be read only. It contains index of insertion (int64) plus
the dead\_time delta of the interval for each channel in float32 type. First row always points to first event with
zero dead times for all channels. First real dead time value is stored to the second row.
\index{find() (listmode.data.TimeCache method)@\spxentry{find()}\spxextra{listmode.data.TimeCache method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache.find}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{find}}}{\emph{\DUrole{n}{t\_slice}}, \emph{\DUrole{n}{ch}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Finding indices in self.timing that contain the t\_slice time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_slice}} \textendash{} tuple of nanosecond values defining a slice in time

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ch}} \textendash{} If specified will return only indices in which dead time has been given for ch. This is mainly used
by get\_timing to interpolate the dead time.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
indices to self.timing containing the time slice.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dead\_time() (listmode.data.TimeCache method)@\spxentry{get\_dead\_time()}\spxextra{listmode.data.TimeCache method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache.get_dead_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_dead\_time}}}{\emph{\DUrole{n}{t\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Return the dead time of the time slice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_slice}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar
All dead times in a numpy array. Live and dead times are float values of seconds.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_indices() (listmode.data.TimeCache method)@\spxentry{get\_indices()}\spxextra{listmode.data.TimeCache method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache.get_indices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_indices}}}{\emph{\DUrole{n}{t\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Return start and stop event indices (endpoint not inclusive) that contain the time slice fully using timing
info as a hash.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_slice}} \textendash{} tuple of nanosecond values defining a slice in time. If None full data is returned.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
indices to event data containing the the time slice

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_live\_time() (listmode.data.TimeCache method)@\spxentry{get\_live\_time()}\spxextra{listmode.data.TimeCache method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache.get_live_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_live\_time}}}{\emph{\DUrole{n}{t\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Return live time of the slice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_slice}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar
All live times in a numpy array. Live and dead times are float values of seconds.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_timing() (listmode.data.TimeCache method)@\spxentry{get\_timing()}\spxextra{listmode.data.TimeCache method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache.get_timing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_timing}}}{\emph{\DUrole{n}{t\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Return dead time data for a slice. The first entry is zeros and the second one is interpolated to start
from t\_slice{[}0{]}. Last one is an extra row interpolated to t\_slice{[}1{]}.

\sphinxAtStartPar
If t\_slice is not defined this method returns timing data as it is.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t\_slice}} \textendash{} Time slice (in ns)

\item[{Returns}] \leavevmode
\sphinxAtStartPar
(interpolated) timing data for time slice

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_total\_time() (listmode.data.TimeCache method)@\spxentry{get\_total\_time()}\spxextra{listmode.data.TimeCache method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache.get_total_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_total\_time}}}{\emph{\DUrole{n}{t\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Return total time of the time slice or total time of measurement, if t\_slice is None.
:param t\_slice:
:return: Total time value in nanoseconds

\end{fulllineitems}

\index{set() (listmode.data.TimeCache method)@\spxentry{set()}\spxextra{listmode.data.TimeCache method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.TimeCache.set}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set}}}{\emph{\DUrole{n}{timing}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timing}} \textendash{} an opened np.memmap instance containing the timing data (retrieved by read\_binary\_data)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{data\_info() (in module listmode.data)@\spxentry{data\_info()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.data_info}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{data\_info}}}{\emph{\DUrole{n}{info}}, \emph{\DUrole{n}{ch\_list}}}{}
\sphinxAtStartPar
Fills data\_info dict with defaults for parts that are missing. Hardcoded settings for energy, multihit and latency
data will be overwritten if defined in config. A warning is printed if setup is overwritten.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{info}} \textendash{} info dict

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ch\_list}} \textendash{} info dict

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
dict with missing keys filled with defaults.

\end{description}\end{quote}

\end{fulllineitems}

\index{fill\_default\_data() (in module listmode.data)@\spxentry{fill\_default\_data()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.fill_default_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{fill\_default\_data}}}{\emph{\DUrole{n}{cfg}}}{}
\sphinxAtStartPar
Will generate reasonable defaults for parameters omitted for ‘events’ and ‘extras’ data\_info dictionaries. It will
overwrite incompatible parameters. Does not work yet.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} \textendash{} Configuration of the detector.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
data\_info dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_timing() (in module listmode.data)@\spxentry{generate\_timing()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.generate_timing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{generate\_timing}}}{\emph{\DUrole{n}{chfile}}, \emph{\DUrole{n}{pulse\_dead\_time}}, \emph{\DUrole{n}{t\_vec}}}{}
\sphinxAtStartPar
Utility function to generate timing vector if it does not exist. Takes pathlib type
filename, pulse dead time for the channel and t\_vec.

\sphinxAtStartPar
Returns nothing, just writes the data.

\end{fulllineitems}

\index{ipoly2() (in module listmode.data)@\spxentry{ipoly2()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.ipoly2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{ipoly2}}}{\emph{\DUrole{n}{y}}, \emph{\DUrole{o}{*}\DUrole{n}{p}}}{}
\sphinxAtStartPar
Estimates the inverse of 2nd degree polynomial above by dropping the 2nd degree term: returns \textasciitilde{}x given y. Here the
larger root is always returned.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} An energy value or a numpy list of energy values.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} Calibration coefficients, starting from 0th degree coefficient.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Channel values

\end{description}\end{quote}

\end{fulllineitems}

\index{kill\_combinator() (in module listmode.data)@\spxentry{kill\_combinator()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.kill_combinator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{kill\_combinator}}}{\emph{\DUrole{n}{in\_dict}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{ev\_count}}, \emph{\DUrole{n}{name}}}{}
\sphinxAtStartPar
Event is set to zero.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} A dictionary including all datas of the channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} \textendash{} Index of the first hit in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} Number of hits in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the data

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A single value for the hit

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_calibration() (in module listmode.data)@\spxentry{load\_calibration()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.load_calibration}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{load\_calibration}}}{\emph{\DUrole{n}{config}}}{}
\sphinxAtStartPar
Loads calibration for the detector. Calibration gives the 2nd degree function coefficients for calibration for each
channel and for each data type. The data is organized as a dictionary with data types as keys and each data as
numpy arrays with channel in first axis and three coefficients (a, b and c) in second axis.

\sphinxAtStartPar
Missing data is fixed with dummy calibration ({[}0,1,0{]} coefficients), but incompatible data (e.g. wrong number of
channels) will raise an exception.

\sphinxAtStartPar
Old calibration data had keys for peaks used for calibration, but they have been dropped.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config}} \textendash{} The detector config object (obviously missing the calibration info)

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The calibration dictionary. read from disk. Missing data is fixed with dummy calibration, but incompatible

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_config() (in module listmode.data)@\spxentry{load\_config()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.load_config}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{load\_config}}}{\emph{\DUrole{n}{det\_name}}, \emph{\DUrole{n}{local\_cfg}}, \emph{\DUrole{n}{data\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Detector configuration object is a namespace with:
paths into configuration directories and optionally to data.
Contents of the detector configuration file.
Calibration for the detector. Calibration gives the 2nd degree function coefficients for calibration for each
channel and for each data type. The data is organized as a dictionary with data types as keys and each data as
numpy arrays with channel in first axis and three coefficients (a, b and c) in second axis. Omitted calibration
data is replaced with {[}0,1,0{]} coefficients
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{det\_name}} \textendash{} Name of the detector configuration file without the \_cfg.json

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{local\_cfg}} \textendash{} Paths needed to find configurations and data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_name}} \textendash{} Optional path to data, that will be added as “home” into config.path

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
detector configuration object

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_combinator() (in module listmode.data)@\spxentry{max\_combinator()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.max_combinator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{max\_combinator}}}{\emph{\DUrole{n}{in\_dict}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{ev\_count}}, \emph{\DUrole{n}{name}}}{}
\sphinxAtStartPar
Returns the hit that has highest value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_dict}} \textendash{} A dictionary including all datas of the channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} \textendash{} Index of the first hit in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} Number of hits in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the data

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A single value for the hit

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_e\_combinator() (in module listmode.data)@\spxentry{max\_e\_combinator()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.max_e_combinator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{max\_e\_combinator}}}{\emph{\DUrole{n}{in\_dict}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{ev\_count}}, \emph{\DUrole{n}{name}}}{}
\sphinxAtStartPar
Returns the hit that has highest energy value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} A dictionary including all datas of the channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} \textendash{} Index of the first hit in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} Number of hits in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the data

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A single value for the hit

\end{description}\end{quote}

\end{fulllineitems}

\index{mean\_combinator() (in module listmode.data)@\spxentry{mean\_combinator()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.mean_combinator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{mean\_combinator}}}{\emph{\DUrole{n}{in\_dict}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{ev\_count}}, \emph{\DUrole{n}{name}}}{}
\sphinxAtStartPar
Returns the mean of all hits in the event.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} A dictionary including all datas of the channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} \textendash{} Index of the first hit in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} Number of hits in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the data

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A single value for the hit

\end{description}\end{quote}

\end{fulllineitems}

\index{min\_combinator() (in module listmode.data)@\spxentry{min\_combinator()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.min_combinator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{min\_combinator}}}{\emph{\DUrole{n}{in\_dict}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{ev\_count}}, \emph{\DUrole{n}{name}}}{}
\sphinxAtStartPar
Returns the hit that has smallest value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} A dictionary including all datas of the channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} \textendash{} Index of the first hit in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} Number of hits in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the data

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A single value for the hit

\end{description}\end{quote}

\end{fulllineitems}

\index{poly2() (in module listmode.data)@\spxentry{poly2()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.poly2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{poly2}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{o}{*}\DUrole{n}{p}}}{}
\sphinxAtStartPar
Model function for 2nd degree polynomial fit for energy calibration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} A channel value or a numpy list of channel values.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} Calibration coefficients, starting from 0th degree coefficient.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Calibrated x.

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_binary\_data() (in module listmode.data)@\spxentry{read\_binary\_data()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.read_binary_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{read\_binary\_data}}}{\emph{\DUrole{n}{data\_path}}, \emph{\DUrole{n}{base\_name}}, \emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}event\textquotesingle{}}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_path}} \textendash{} Path to the data directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_name}} \textendash{} Base name of the data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} \textendash{} The detector config dictionary

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mode}} \textendash{} What mode of data to read: ‘event’ or ‘channel’.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}
\begin{description}
\item[{The detector configuration is needed for defining the extras:}] \leavevmode
\sphinxAtStartPar
List of dicts defining extra data files, type and number of
columns. extras = \{“name”:’x’, “type”:’t’, “num\_col”:’n’\}, where type
is a numpy type string of the data. Several extras can be defined in
det\_cfg (coord, ch\_flags). These are handled automatically if they are
present.

\end{description}

\sphinxAtStartPar
Some extras, such as coord, need to have additional definitions in the
config. For coord, it is the ‘coordinates’ list which defines the number
of coordinates, the channels the data is found and the order of the
coordinates in i, j notation.

\end{fulllineitems}

\index{strip\_cal() (in module listmode.data)@\spxentry{strip\_cal()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.strip_cal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{strip\_cal}}}{\emph{\DUrole{n}{data\_mat}}, \emph{\DUrole{n}{coord}}, \emph{\DUrole{n}{strip\_cal}}, \emph{\DUrole{n}{coord\_ch}}}{}
\sphinxAtStartPar
Calculates strip calibration for coordinate data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_mat}} \textendash{} data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coord}} \textendash{} coordinates

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{strip\_cal}} \textendash{} calibration matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coord\_ch}} \textendash{} order of coordinate channels

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{sum\_combinator() (in module listmode.data)@\spxentry{sum\_combinator()}\spxextra{in module listmode.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/data:listmode.data.sum_combinator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.data.}}\sphinxbfcode{\sphinxupquote{sum\_combinator}}}{\emph{\DUrole{n}{in\_dict}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{ev\_count}}, \emph{\DUrole{n}{name}}}{}
\sphinxAtStartPar
Returns the sum of all hits in the event.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_list}} \textendash{} A dictionary including all datas of the channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} \textendash{} Index of the first hit in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_count}} \textendash{} Number of hits in the event

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the data

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A single value for the hit

\end{description}\end{quote}

\end{fulllineitems}



\section{Plot}
\label{\detokenize{autodocs/plot:module-listmode.plot}}\label{\detokenize{autodocs/plot:plot}}\label{\detokenize{autodocs/plot::doc}}\index{module@\spxentry{module}!listmode.plot@\spxentry{listmode.plot}}\index{listmode.plot@\spxentry{listmode.plot}!module@\spxentry{module}}\index{Axis (class in listmode.plot)@\spxentry{Axis}\spxextra{class in listmode.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Axis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.plot.}}\sphinxbfcode{\sphinxupquote{Axis}}}{\emph{\DUrole{n}{axis\_info}}, \emph{\DUrole{n}{det\_cfg}}, \emph{\DUrole{n}{time\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Axis info is a class handling a single data axis in a plot. Axis takes care of binning, calibration, tick spacing
and labeling of the plot. For this to happen, Axis needs not only axis configuration but also detector configuration
to know about the data it is showing.

\sphinxAtStartPar
Axis is not meant to be used directly. It is a part of Plot.
\index{update() (listmode.plot.Axis method)@\spxentry{update()}\spxextra{listmode.plot.Axis method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Axis.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{data}}}{}
\sphinxAtStartPar
Histogram is updated with the filtered selected data in a list called datas.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} Numpy array of data values.

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Filter1d (class in listmode.plot)@\spxentry{Filter1d}\spxextra{class in listmode.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Filter1d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.plot.}}\sphinxbfcode{\sphinxupquote{Filter1d}}}{\emph{\DUrole{n}{axes}}}{}
\sphinxAtStartPar
Filter collects the histogram. It defines its range by the axes.
\index{update() (listmode.plot.Filter1d method)@\spxentry{update()}\spxextra{listmode.plot.Filter1d method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Filter1d.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{datas}}}{}
\sphinxAtStartPar
Histogram is updated with the filtered selected data in a list called datas.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datas}} \textendash{} List of numpy arrays of data values.

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Filter2d (class in listmode.plot)@\spxentry{Filter2d}\spxextra{class in listmode.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Filter2d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.plot.}}\sphinxbfcode{\sphinxupquote{Filter2d}}}{\emph{\DUrole{n}{axes}}}{}
\sphinxAtStartPar
In 2d\sphinxhyphen{}filter the \_\_init\_\_ and \_build are overridden to handle two axes.

\end{fulllineitems}

\index{Gate (class in listmode.plot)@\spxentry{Gate}\spxextra{class in listmode.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Gate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.plot.}}\sphinxbfcode{\sphinxupquote{Gate}}}{\emph{\DUrole{n}{gate\_info}}, \emph{\DUrole{n}{det\_cfg}}, \emph{\DUrole{n}{cal}}, \emph{\DUrole{n}{bitmask}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Gate is a simple class defining a single filter for data streamed through it’s update method. It is defined by
gate\_info dictionary with following keys:
“channel”:  The channel the gate is for.
“dtype”:     The data type the gate is for.
“range”:    A list of ranges defining where the gate is passing through (if null or coincident) or blocking (if
\begin{quote}

\sphinxAtStartPar
anticoincident). Each range is a list of start and stop values in calibrated units.
\end{quote}
\begin{description}
\item[{“coinc”:    Defines coincidence (positive integer), anticoincidence (negative integer) or null coincidence. A null}] \leavevmode
\sphinxAtStartPar
gate will still limit the plot axis and is thus implicitly handled as coincident if it is defined for
one of the plot axes.

\end{description}
\index{update() (listmode.plot.Gate method)@\spxentry{update()}\spxextra{listmode.plot.Gate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Gate.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{data\_dict}}, \emph{\DUrole{n}{mask}}}{}
\sphinxAtStartPar
Update runs the data\_dict through the gate selection and modifies the input mask.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_dict}} \textendash{} Full data dict of the chunk

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} \textendash{} A mask defining events that pass. The mask is modified in\sphinxhyphen{}place.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Plot (class in listmode.plot)@\spxentry{Plot}\spxextra{class in listmode.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{listmode.plot.}}\sphinxbfcode{\sphinxupquote{Plot}}}{\emph{\DUrole{n}{canvas\_cfg}}, \emph{\DUrole{n}{det\_cfg}}, \emph{\DUrole{n}{time\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_idx}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Plot is a manager class for handling a histogram to plot. A plot itself is a combination of its axes and its filter.
Axes objects are responsible for the calibration, limits and unit labels of the plot. A plot is filled by feeding
it with data chunks via its update\sphinxhyphen{}method. Filter is the actual histogramming function collecting output of each
chunk. Plot class can return the data and axes information as numpy array via get\_data\sphinxhyphen{}method and title, legend and
axis label strings via its get\_plot\_labels\sphinxhyphen{}method.

\sphinxAtStartPar
Plot configuration dictionary defines the data in the plot as well as the plotting parameters, such as labels,
scales etc. The Plot class uses only the information in plot\_cfg list and the name of the config. Only one plot can
be defined per Plot object. However multiple plots can be stacked into the plot\_cfg list of the plot configuration.
If all of the plots are 1d and have same axes they can be plotted into a single figure.

\sphinxAtStartPar
Creating figures and handling how to stack plots into figures is done explicitly by the user. Two Plot instances can
be compared for equality to help with stacking. The comparison returns True only if the two plots can be shown in
the same axes.
\index{get\_data() (listmode.plot.Plot method)@\spxentry{get\_data()}\spxextra{listmode.plot.Plot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Plot.get_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_data}}}{\emph{\DUrole{n}{calibrate}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Returns the histogram as numpy array along with bins for each axis and text for legend/export filename.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibrate}} \textendash{} Return calibrated bins

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_plot\_labels() (listmode.plot.Plot method)@\spxentry{get\_plot\_labels()}\spxextra{listmode.plot.Plot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Plot.get_plot_labels}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_plot\_labels}}}{\emph{\DUrole{n}{calibrate}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Returns title legend and axis labels.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibrate}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{update() (listmode.plot.Plot method)@\spxentry{update()}\spxextra{listmode.plot.Plot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.Plot.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{data\_dict}}}{}
\sphinxAtStartPar
Update method runs the relevant data through all the gates to produce a final mask and runs the masked data into
axes (for axis limit updates) and filter (for histogramming).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_dict}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{data\_plot() (in module listmode.plot)@\spxentry{data\_plot()}\spxextra{in module listmode.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.data_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.plot.}}\sphinxbfcode{\sphinxupquote{data\_plot}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{plot\_list}}, \emph{\DUrole{n}{time\_slice}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{calibrate}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Demo function to produce data from a plot config dictionary.

\end{fulllineitems}

\index{get\_ticks() (in module listmode.plot)@\spxentry{get\_ticks()}\spxextra{in module listmode.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/plot:listmode.plot.get_ticks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.plot.}}\sphinxbfcode{\sphinxupquote{get\_ticks}}}{\emph{\DUrole{n}{max\_x}}, \emph{\DUrole{n}{numticks}\DUrole{o}{=}\DUrole{default_value}{30}}}{}
\sphinxAtStartPar
Tries to divide the numticks to the axis in a smart way. Probably not used atm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_x}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{numticks}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The ticks in a numpy array

\end{description}\end{quote}

\end{fulllineitems}



\section{Utils}
\label{\detokenize{autodocs/utils:module-listmode.utils}}\label{\detokenize{autodocs/utils:utils}}\label{\detokenize{autodocs/utils::doc}}\index{module@\spxentry{module}!listmode.utils@\spxentry{listmode.utils}}\index{listmode.utils@\spxentry{listmode.utils}!module@\spxentry{module}}\index{delete\_channel\_data() (in module listmode.utils)@\spxentry{delete\_channel\_data()}\spxextra{in module listmode.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/utils:listmode.utils.delete_channel_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.utils.}}\sphinxbfcode{\sphinxupquote{delete\_channel\_data}}}{\emph{\DUrole{n}{data\_path}}, \emph{\DUrole{n}{base\_name}}, \emph{\DUrole{n}{cfg}}}{}
\sphinxAtStartPar
Used to delete channel files after parsing.
:param data\_path:
:param base\_name:
:param cfg:
:return:

\end{fulllineitems}

\index{find\_data\_files() (in module listmode.utils)@\spxentry{find\_data\_files()}\spxextra{in module listmode.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/utils:listmode.utils.find_data_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.utils.}}\sphinxbfcode{\sphinxupquote{find\_data\_files}}}{\emph{\DUrole{n}{data\_path}}, \emph{\DUrole{n}{base\_name}}, \emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{mode}}}{}
\sphinxAtStartPar
Generate filenames (paths) of all the data produced by config. You can select either ‘event’ or ‘channel’
type names.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_path}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_name}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mode}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
timing, energy, time and extras filenames as lists. For event data the first (and only) item in the list
is the relevant filename. For channel data there is a single name for every channel. Extra names are given
as a list of names, one per extra (for each channel as in other data).

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_plot\_config() (in module listmode.utils)@\spxentry{load\_plot\_config()}\spxextra{in module listmode.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/utils:listmode.utils.load_plot_config}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.utils.}}\sphinxbfcode{\sphinxupquote{load\_plot\_config}}}{\emph{\DUrole{n}{config}}, \emph{\DUrole{n}{plot\_name}}}{}
\sphinxAtStartPar
Loads a plot configuration from a json file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config}} \textendash{} Config data that has the config.path in it

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plot\_name\_list}} \textendash{} plot config name without the \_plotcfg.json postfix or a list of names

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a plot config dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_strip\_cal() (in module listmode.utils)@\spxentry{load\_strip\_cal()}\spxextra{in module listmode.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/utils:listmode.utils.load_strip_cal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.utils.}}\sphinxbfcode{\sphinxupquote{load\_strip\_cal}}}{\emph{\DUrole{n}{config}}}{}
\sphinxAtStartPar
Load strip calibration files if they exist.

\end{fulllineitems}

\index{load\_style\_sheet() (in module listmode.utils)@\spxentry{load\_style\_sheet()}\spxextra{in module listmode.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/utils:listmode.utils.load_style_sheet}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.utils.}}\sphinxbfcode{\sphinxupquote{load\_style\_sheet}}}{\emph{\DUrole{n}{config}}, \emph{\DUrole{n}{style\_name\_list}}}{}
\sphinxAtStartPar
Loads a matplotlib style sheet written as a json file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config}} \textendash{} Detector configuration object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{style\_name\_list}} \textendash{} style path or a list of paths

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of style dictionaries

\end{description}\end{quote}

\end{fulllineitems}



\section{Misc}
\label{\detokenize{autodocs/misc:misc}}\label{\detokenize{autodocs/misc::doc}}
\sphinxAtStartPar
Here are few random helper functions useful in some special situations.

\phantomsection\label{\detokenize{autodocs/misc:module-listmode.misc}}\index{module@\spxentry{module}!listmode.misc@\spxentry{listmode.misc}}\index{listmode.misc@\spxentry{listmode.misc}!module@\spxentry{module}}\index{atoi() (in module listmode.misc)@\spxentry{atoi()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.atoi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{atoi}}}{\emph{\DUrole{n}{text}}}{}
\sphinxAtStartPar
Convert integer text to int, otherwise return the original string. Used to parse long filenames with numbering
in the filenme.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{text}} \textendash{} Input string.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
If text is convertible to integer this returns the integer, otherwise the original text.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_monotonousness() (in module listmode.misc)@\spxentry{check\_monotonousness()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.check_monotonousness}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{check\_monotonousness}}}{\emph{\DUrole{n}{vector}}}{}
\sphinxAtStartPar
Checks if values in a given vector are monotonously increasing. If they are not, the index of the first element
that breaks the monotonousness is returned. None.
:param vector:
:return: Index of first out\sphinxhyphen{}of\sphinxhyphen{}place element in vector. None is returned if vector is monotonous.

\end{fulllineitems}

\index{fromisoformat() (in module listmode.misc)@\spxentry{fromisoformat()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.fromisoformat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{fromisoformat}}}{\emph{\DUrole{n}{dt\_string}}}{}
\sphinxAtStartPar
Converts string returned by python 3.7+ datetime.toisoformat() into a proper datetime object. This was needed
because the isoformat seems to be fairly new thing in python and not present in 3.6 or earlier.

\sphinxAtStartPar
The string to be parsed is of the format: “2020\sphinxhyphen{}06\sphinxhyphen{}09T04:00:01.434322”
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt\_string}} \textendash{} isoformat string

\item[{Returns}] \leavevmode
\sphinxAtStartPar
datetime object

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_run\_id() (in module listmode.misc)@\spxentry{make\_run\_id()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.make_run_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{make\_run\_id}}}{\emph{\DUrole{n}{base\_path}}, \emph{\DUrole{n}{base\_name}}}{}
\sphinxAtStartPar
Make sure old data is never overwritten. Adds an incremented number to base name. If a datafile with the same name
already exists, then the number is incremented.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_path}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_name}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{natural\_keys() (in module listmode.misc)@\spxentry{natural\_keys()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.natural_keys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{natural\_keys}}}{\emph{\DUrole{n}{text}}}{}
\sphinxAtStartPar
alist.sort(key=natural\_keys) sorts number strings in human order (‘1’ before ‘10’) and so on.
Taken from:
\sphinxurl{http://nedbatchelder.com/blog/200712/human\_sorting.html}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{text}} \textendash{} input string

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_file() (in module listmode.misc)@\spxentry{parse\_file()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.parse_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{parse\_file}}}{\emph{\DUrole{n}{dir\_name}}, \emph{\DUrole{n}{file\_name}}, \emph{\DUrole{n}{raw\_ext}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Finds data files (matching optional file\_name prefix) from directory. First event mode data files are searched for, if not
found, then channel mode files and finally raw data files are searched for. All files in the directory (or matching
a given base name) are returned

\sphinxAtStartPar
Problem is that some raw data formats (Caen, native channel data) have multiple files per measurement. This is fixed
by having a wildcard expression of the postfix of the filename included in the extension
like ch???.dat for caen data. Unique names are then automatically resolved by saving the base names as keys to a
dictionary (which is ordered in py3 unlike the set?).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dir\_name}} \textendash{} The directory containing the data

\item[{Param}] \leavevmode
\sphinxAtStartPar
file\_name: optional base name for data files if they are named differently from directory.

\item[{Param}] \leavevmode
\sphinxAtStartPar
raw\_ext: optional wildcard pattern for raw data files.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of base names of data files in the directory (matching file\_name prefix)

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_time() (in module listmode.misc)@\spxentry{parse\_time()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.parse_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{parse\_time}}}{\emph{\DUrole{n}{args}}}{}
\sphinxAtStartPar
Parses command line time slice with optional timebase argument. Timebase argument is one of ‘s’, ‘m’, ‘h’ or ‘d’.
Timebase argument, if it exists, is the last value in the list or tuple of (start, {[}stop{]}, {[}timebase{]}) that defines
the slice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} A list or tuple of (start, {[}stop{]}, {[}timebase{]}). All input arguments are strings.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns parsed time slice (start, stop) in integer nanoseconds.

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_timebase() (in module listmode.misc)@\spxentry{parse\_timebase()}\spxextra{in module listmode.misc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/misc:listmode.misc.parse_timebase}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.misc.}}\sphinxbfcode{\sphinxupquote{parse\_timebase}}}{\emph{\DUrole{n}{args}}}{}
\sphinxAtStartPar
Parses the timebase string if it exists, supplies default if it does not and returns the timebase multiplier
with the other arguments.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} A list or tuple of (start, {[}stop{]}, {[}timebase{]}). All input arguments are strings.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
timebase multiplier for ns\sphinxhyphen{}transformation and list of the other arguments.

\end{description}\end{quote}

\end{fulllineitems}



\section{Loaders}
\label{\detokenize{autodocs/loaders:module-listmode.loaders}}\label{\detokenize{autodocs/loaders:loaders}}\label{\detokenize{autodocs/loaders::doc}}\index{module@\spxentry{module}!listmode.loaders@\spxentry{listmode.loaders}}\index{listmode.loaders@\spxentry{listmode.loaders}!module@\spxentry{module}}\index{caen\_loader() (in module listmode.loaders)@\spxentry{caen\_loader()}\spxextra{in module listmode.loaders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/loaders:listmode.loaders.caen_loader}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.loaders.}}\sphinxbfcode{\sphinxupquote{caen\_loader}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{data\_path}}}{}
\sphinxAtStartPar
Reads data saved by Caen MCA. Caen data format does not record time and date of data taking, so these are calculated
from the datafile modification timestamp.

\sphinxAtStartPar
In case there are several runs on single data (appended to same file) the results may be unpredictable. In the
future all appends should be recognized and extracted as channel files, but only first one is loaded as data.

\sphinxAtStartPar
The loaded channel list is compared to one in cfg and if not matching an error is generated.

\sphinxAtStartPar
Caen loader supports two kinds of bitmask extra data: Pileup and flags. Flags is set whenever there the ‘extras’
data is nonzero. Pileup flag is set whenever the energy for the channel is zero, signaling a pileup event (unless
set to return energy value).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self}} \textendash{} Calling Data instance. This is set when the loader is set as class method.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_path}} \textendash{} path to a file

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{dspec\_loader() (in module listmode.loaders)@\spxentry{dspec\_loader()}\spxextra{in module listmode.loaders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/loaders:listmode.loaders.dspec_loader}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.loaders.}}\sphinxbfcode{\sphinxupquote{dspec\_loader}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{data\_path}}}{}
\end{fulllineitems}

\index{g4\_loader() (in module listmode.loaders)@\spxentry{g4\_loader()}\spxextra{in module listmode.loaders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/loaders:listmode.loaders.g4_loader}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.loaders.}}\sphinxbfcode{\sphinxupquote{g4\_loader}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{data\_path}}}{}
\end{fulllineitems}

\index{panda\_loader() (in module listmode.loaders)@\spxentry{panda\_loader()}\spxextra{in module listmode.loaders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/loaders:listmode.loaders.panda_loader}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.loaders.}}\sphinxbfcode{\sphinxupquote{panda\_loader}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{data\_path}}}{}
\sphinxAtStartPar
Reads PANDA data. Even though PANDA data is already reconstructed in event mode, it will still be broken down
to channel files for the pipeline. PANDA clock is used for dead time and timing. DSSSD will be handled as two
detectors with associated coordinate extra. Due to this and the capability of the multi\sphinxhyphen{}hit processor to combine
data from several channels the DSSSD data will be strip calibrated when read from the raw file. If strip calibration
needs to be redone later one has to make a dummy calibration to access the uncalibrated strip values.

\sphinxAtStartPar
If PANDA data is divided into several files, only one is converted and loaded. In this case either start\_time,
stop\_time or both are undefined and will be calculated from data length and, in worst case, file modification
time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self}} \textendash{} Calling Data instance. This is set when the loader is set as class method.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_path}} \textendash{} path to a file

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{pixie4\_loader() (in module listmode.loaders)@\spxentry{pixie4\_loader()}\spxextra{in module listmode.loaders}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autodocs/loaders:listmode.loaders.pixie4_loader}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{listmode.loaders.}}\sphinxbfcode{\sphinxupquote{pixie4\_loader}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{data\_path}}}{}
\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{l}
\item\relax\sphinxstyleindexentry{listmode.data}\sphinxstyleindexpageref{autodocs/data:\detokenize{module-listmode.data}}
\item\relax\sphinxstyleindexentry{listmode.loaders}\sphinxstyleindexpageref{autodocs/loaders:\detokenize{module-listmode.loaders}}
\item\relax\sphinxstyleindexentry{listmode.misc}\sphinxstyleindexpageref{autodocs/misc:\detokenize{module-listmode.misc}}
\item\relax\sphinxstyleindexentry{listmode.plot}\sphinxstyleindexpageref{autodocs/plot:\detokenize{module-listmode.plot}}
\item\relax\sphinxstyleindexentry{listmode.utils}\sphinxstyleindexpageref{autodocs/utils:\detokenize{module-listmode.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}