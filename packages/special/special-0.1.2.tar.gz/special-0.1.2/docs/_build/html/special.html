<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>special.chi &mdash; special  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Contributions" href="about.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/Special_logo.jpeg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="features.html">What makes it <cite>special</cite>?</a></li>
<li class="toctree-l1"><a class="reference internal" href="trimmed_readme.html">TL;DR setup guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="trimmed_readme.html#installation-and-dependencies">Installation and dependencies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html"><em>special</em> tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#1.-Loading-the-data">1. Loading the data</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#2.-Spectral-correlation-matrix">2. Spectral correlation matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#3.-Preliminary-spectral-analysis">3. Preliminary spectral analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#4.-MCMC-sampler-examples">4. MCMC sampler examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#5.-Comparison-of-results">5. Comparison of results</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#6.-Nested-sampler-examples">6. Nested sampler examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#7.-Best-fit-template-spectrum">7. Best-fit template spectrum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="about.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html#questions-and-suggestions">Questions and suggestions</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html#acknowledgements">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Package content</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">special.chi</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.config">special.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.fits">special.fits</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.mcmc_sampling">special.mcmc_sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.model_resampling">special.model_resampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="#special-nested-sampling">special.nested_sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.spec_corr">special.spec_corr</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.spec_indices">special.spec_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="#special-template-fit">special.template_fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.utils_mcmc">special.utils_mcmc</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.utils_spec">special.utils_spec</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">special</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>special.chi</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/VChristiaens/special/blob/main/docs/special.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="special-chi">
<span id="special"></span><h1>special.chi<a class="headerlink" href="#special-chi" title="Permalink to this headline"></a></h1>
</div>
<div class="section" id="module-special.config">
<span id="special-config"></span><h1>special.config<a class="headerlink" href="#module-special.config" title="Permalink to this headline"></a></h1>
<p>Module with configuration parameters, timing functions and multiprocessing
utilities (inspired from VIP).</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.config.time_fin">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">time_fin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#time_fin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.time_fin" title="Permalink to this definition"></a></dt>
<dd><p>Return the execution time of a script.</p>
<p>It requires the initialization  with the function time_ini().</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.config.time_ini">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">time_ini</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#time_ini"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.time_ini" title="Permalink to this definition"></a></dt>
<dd><p>Set and print the time at which the script started.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>start_time</strong> – Starting time.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.config.timing">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">timing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#timing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.timing" title="Permalink to this definition"></a></dt>
<dd><p>Print the execution time of a script.</p>
<p>It requires the initialization  with the function time_ini().</p>
</dd></dl>

</div>
<div class="section" id="module-special.fits">
<span id="special-fits"></span><h1>special.fits<a class="headerlink" href="#module-special.fits" title="Permalink to this headline"></a></h1>
<p>Module with various fits handling functions (same as in VIP)</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.fits.info_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">info_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitsfilename</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#info_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.info_fits" title="Permalink to this definition"></a></dt>
<dd><p>Print the information about a fits file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>str</em>) – Path to the fits file.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the astropy.io.fits.open() function. E.g.
“output_verify” can be set to ignore, in case of non-standard header.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.fits.open_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">open_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fitsfilename</span></em>, <em class="sig-param"><span class="pre">n=0</span></em>, <em class="sig-param"><span class="pre">header=False</span></em>, <em class="sig-param"><span class="pre">ignore_missing_end=False</span></em>, <em class="sig-param"><span class="pre">precision=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em>, <em class="sig-param"><span class="pre">return_memmap=False</span></em>, <em class="sig-param"><span class="pre">verbose=True</span></em>, <em class="sig-param"><span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#open_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.open_fits" title="Permalink to this definition"></a></dt>
<dd><p>Load a fits file into a memory as numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>string</em><em> or </em><em>pathlib.Path</em>) – Name of the fits file or <code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code> object</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>optional</em>) – It chooses which HDU to open. Default is the first one.</p></li>
<li><p><strong>header</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the header along with the data or not.</p></li>
<li><p><strong>precision</strong> (<em>numpy dtype</em><em>, </em><em>optional</em>) – Float precision, by default np.float32 or single precision float.</p></li>
<li><p><strong>ignore_missing_end</strong> (<em>bool optional</em>) – Allows to open fits files with a header missing END card.</p></li>
<li><p><strong>return_memmap</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the function returns the handle to the FITS file opened by
mmap. With the hdulist, array data of each HDU to be accessed with mmap,
rather than being read into memory all at once. This is particularly
useful for working with very large arrays that cannot fit entirely into
physical memory.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True prints message of completion.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the astropy.io.fits.open() function. E.g.
“output_verify” can be set to ignore, in case of non-standard header.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hdulist</strong> (<em>hdulist</em>) – [memmap=True] FITS file <code class="docutils literal notranslate"><span class="pre">n</span></code> hdulist.</p></li>
<li><p><strong>data</strong> (<em>numpy ndarray</em>) – [memmap=False] Array containing the frames of the fits-cube.</p></li>
<li><p><strong>header</strong> (<em>dict</em>) – [memmap=False, header=True] Dictionary containing the fits header.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.fits.write_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">write_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fitsfilename</span></em>, <em class="sig-param"><span class="pre">array</span></em>, <em class="sig-param"><span class="pre">header=None</span></em>, <em class="sig-param"><span class="pre">output_verify='exception'</span></em>, <em class="sig-param"><span class="pre">precision=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em>, <em class="sig-param"><span class="pre">verbose=True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#write_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.write_fits" title="Permalink to this definition"></a></dt>
<dd><p>Write array and header into FTIS file.</p>
<p>If there is a previous file with the same filename then it’s replaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>string</em>) – Full path of the fits file to be written.</p></li>
<li><p><strong>array</strong> (<em>numpy ndarray</em>) – Array to be written into a fits file.</p></li>
<li><p><strong>header</strong> (<em>numpy ndarray</em><em>, </em><em>optional</em>) – Array with header.</p></li>
<li><p><strong>output_verify</strong> (<em>str</em><em>, </em><em>optional</em>) – {“fix”, “silentfix”, “ignore”, “warn”, “exception”}
Verification options:
<a class="reference external" href="https://docs.astropy.org/en/stable/io/fits/api/verification.html">https://docs.astropy.org/en/stable/io/fits/api/verification.html</a></p></li>
<li><p><strong>precision</strong> (<em>numpy dtype</em><em>, </em><em>optional</em>) – Float precision, by default np.float32 or single precision float.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True prints message.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.mcmc_sampling">
<span id="special-mcmc-sampling"></span><h1>special.mcmc_sampling<a class="headerlink" href="#module-special.mcmc_sampling" title="Permalink to this headline"></a></h1>
<p>Module with the MCMC (<code class="docutils literal notranslate"><span class="pre">emcee</span></code>) sampling for model spectra parameter
estimation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.chain_zero_truncated">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">chain_zero_truncated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ln_proba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#chain_zero_truncated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.chain_zero_truncated" title="Permalink to this definition"></a></dt>
<dd><p>Return the Markov chain with the dimension: walkers x steps* x parameters,
where steps* is the last step before having 0 (not yet constructed chain).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The MCMC chain.</p></li>
<li><p><strong>ln_proba</strong> (<em>numpy.array</em><em>, </em><em>opt</em>) – Corresponding ln-probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out</strong> (<em>numpy.array</em>) – The truncated MCMC chain, that is to say, the chain which only contains
relevant information.</p></li>
<li><p><strong>out_ln_proba</strong> (<em>numpy.array</em>) – If ln_proba is provided as input, out_ln_proba contains the
zero-truncated ln-proba (i.e. matching shape with non-zero samples)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.confidence">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">confidence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cfd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">68.27</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaussian_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#confidence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.confidence" title="Permalink to this definition"></a></dt>
<dd><p>Determine the highly probable value for each model parameter, as well as
the 1-sigma confidence interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>isamples</strong> (<em>numpy.array</em>) – The independent samples for each model parameter.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- next the planet photometric radius ‘R’,
- (optionally) the optical extinction ‘Av’.
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution</p></li>
<li><p><strong>cfd</strong> (<em>float</em><em>, </em><em>optional</em>) – The confidence level given in percentage.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins used to sample the posterior distributions.</p></li>
<li><p><strong>gaussian_fit</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If True, a gaussian fit is performed in order to determine (mu,sigma)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>n</em><em>, </em><em>) </em><em>numpy ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – An array of weights for each sample.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Display information in the shell.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If “True”, a txt file with the results is saved in the output
repository.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Only used if a text file is saved summarizing results+bounds+priors.
Should be the same bounds as provided to the MCMC.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Only used if a text file is saved summarizing results+bounds+priors.
Should be the same priors as provided to the MCMC.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – Additional attributes are passed to the matplotlib hist() method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – A 2 elements tuple with the highly probable solution and the confidence
interval.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.lnlike">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">lnlike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#lnlike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.lnlike" title="Permalink to this definition"></a></dt>
<dd><p>Define the likelihood log-function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of</p></li>
</ul>
<p>model parameters.
- Set to None for a pure n-blackbody fit, n=1,2,…
- Note1: model grids should not contain grids on radius and Av, but
these should still be passed in initial_state (Av optional).
- Note2: for a combined grid model + black body, just provide
the grid parameter list here, and provide values for ‘Tbbn’ and ‘Rbbn’
in initial_state, labels and bounds.</p>
</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over model_name/model_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in model_interpolation()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:
1) the wavelength (in mu);
2) a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);
3) the FWHM of the gaussian (or None if to be set automatically);
4) whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).
Examples:
- em_lines = {‘BrG’:(2.1667,’F’,None, None)};
- em_lines = {‘BrG’:(2.1667,’LogL’, 100, ‘km/s’)}</p>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral resolution of
the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental spectral resolution(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of spectral resolution values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_res provided above, and i in
[1,n_instru] for points associated to instru_res[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwith of photometric
filters used. Weights will be proportional to dlbda_obs/lbda_obs if
dlbda_obs is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The log of the likelihood.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.lnprob">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">lnprob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#lnprob"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.lnprob" title="Permalink to this definition"></a></dt>
<dd><p>Define the probability log-function as the sum between the prior and
likelihood log-functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – The model parameters.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
All keywords that are neither ‘R’, ‘Av’ nor ‘M’ will
be considered model grid parameters.
Example for BT-SETTL: bounds = {‘Teff’:(1000,2000), ‘logg’:(3.0,4.5),
‘R’:(0.1,5), ‘Av’:(0.,2.5)}
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Set to None for a pure n-blackbody fit, n=1,2,…</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
<li><p>Note2: for a combined grid model + black body, just provide         the grid parameter list here, and provide values for ‘Tbbn’ and ‘Rbbn’         in initial_state, labels and bounds.</p></li>
</ul>
</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over model_name/model_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in model_interpolation()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:
1) the wavelength (in mu);
2) a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);
3) the FWHM of the gaussian (or None if to be set automatically);
4) whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.
The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).
Examples:
em_lines = {‘BrG’:(2.1667,’F’,None, None)};
em_lines = {‘BrG’:(2.1667,’LogL’, 100, ‘km/s’)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental spectral resolution(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of spectral resolution values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_res provided above, and i in
[1,n_instru] for points associated to instru_res[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwith of photometric
filters used. Weights will be proportional to dlbda_obs/lbda_obs if
dlbda_obs is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in bounds dictionary but not here) will
be associated no prior.
e.g. priors = {‘Teff’:(1600,100), ‘logg’:(3.5,0.5), ‘R’:(1.6,0.1),
‘Av’:(1.8,0.2), ‘M’:(10,3)}</p>
<p>Important: dictionary entry names should match exactly those of bounds.</p>
</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The probability log-function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.mcmc_spec_sampling">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">mcmc_spec_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resamp_before</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ini_ball</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_supp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_maxgap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ac_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ac_count_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhat_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhat_count_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'resamp_grid.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'special/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nproc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#mcmc_spec_sampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.mcmc_spec_sampling" title="Permalink to this definition"></a></dt>
<dd><p>Runs an affine invariant MCMC sampling algorithm in order to determine
the most likely parameters for given spectral model and observed spectrum.
Allowed features:
* Spectral models can either be read from a grid (e.g. BT-SETTL) or     be purely parametric (e.g. a blackbody model).
* Extinction (A_V) and total-to-selective optical extinction ratio     (R_V) can be sampled. Default: A_V=0. If non-zero, default R_V=3.1 (ISM).
* A dictionary of emission lines can be provided and their flux can     be sampled too.
* Gaussian priors can be provided for each parameter, including the     mass of the object. The latter will be used if ‘logg’ is a parameter.
* Spectral correlation between measurements will be taken into account if provided in ‘instru_corr’.
* Convolution of the model spectra with instrumental FWHM or     photometric filter can be performed using ‘instru_res’ and/or     ‘filter_reader’ (done before resampling to observed).
* The weight of each observed point will be directly proportional to     Delta lbda_i/lbda_i, where Delta lbda_i is either the FWHM of the     photometric filter (imager) or the width of the spectral channel (IFS).
* MCMC convergence criterion can either be based on auto-correlation     time (default) or the Gelman-Rubin test.</p>
<p>The result of this procedure is a chain with the samples from the posterior
distributions of each of the free parameters in the model.
More details in Christiaens et al. (2021).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Set to None for a pure n-blackbody fit, n=1,2,…</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
<li><p>Note2: for a combined grid model + black body, just provide         the grid parameter list here, and provide values for ‘Tbbn’ and ‘Rbbn’         in initial_state, labels and bounds.</p></li>
</ul>
</p></li>
<li><p><strong>initial_state</strong> (<em>tuple of floats</em>) – Initial guess on the best fit parameters of the spectral fit. Length of
the tuple should match the total number of free parameters. Walkers
will all be initialised in a small ball of parameter space around that
first guess.
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the intensity of emission lines (labels must match         those in the em_lines dict), in units of the model spectrum (x mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
Example for BT-SETTL: bounds = {‘Teff’:(1000,2000), ‘logg’:(3.0,4.5),
‘R’:(0.1,5), ‘Av’:(0.,2.5)}
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’ (if both exist).</p></li>
<li><p><strong>resamp_before</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to prepare the whole grid of resampled models before entering
the MCMC, i.e. to avoid doing it at every MCMC step. Recommended.
Only reason not to: model grid is too large and individual models
require being opened and resampled at each step.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over filename/file_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in model_interpolation()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:
1) the wavelength (in mu);
2) a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);
3) the FWHM of the gaussian (or None if to be set automatically);
4) whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.
The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).
Examples:
em_lines = {‘BrG’:(2.1667,’F’, None, None)};
em_lines = {‘BrG’:(2.1667,’LogL’, 100, ‘km/s’)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width and FWHM of the photometric filters
used for the input spectrum. It is used to infer which part(s) of a
combined spectro+photometric spectrum should involve
convolution+subsampling (model resolution higher than measurements),
interpolation (the opposite), or convolution by the transmission curve
of a photometric filter. If not provided, it will be inferred from the
difference between consecutive lbda_obs points (i.e. inaccurate for a
combined spectrum).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using <cite>spec_corr.spectral_correlation()</cite>. In case of
a spectrum obtained with different instruments, build it with
<cite>spec_corr.combine_corrs()</cite>. If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental spectral resolution(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of spectral resolution values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_res provided above, and i in
[1,n_instru] for points associated to instru_res[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwith of photometric
filters used. Weights will be proportional to dlbda_obs/lbda_obs if
dlbda_obs is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:
- first row containing header
- starting from 2nd row: 1st column: wavelength, 2nd col.: transmission
- Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: Only what is in parentheses         matters.</p>
<p>Important: filter files should all have the same format and WL units.</p>
</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in bounds dictionary but not here) will
be associated no prior.
e.g. priors = {‘Teff’:(1600,100), ‘logg’:(3.5,0.5), ‘R’:(1.6,0.1),
‘Av’:(1.8,0.2), ‘M’:(10,3)}
Important: dictionary entry names should match exactly those of bounds.</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate non-existing models in the grid. Only used if
resamp_before is set to True.</p></li>
<li><p><strong>ini_ball</strong> (<em>float</em><em> or </em><em>string</em><em>, </em><em>default=1e-1</em>) – Size of the initial ball in parameter space from which walkers start
their chain. If “uniform” is provided, a uniform ini_ball spanning
the bounds interval will be used to initialise walkers.</p></li>
<li><p><strong>a</strong> (<em>float</em><em>, </em><em>default=2.0</em>) – The proposal scale parameter. See notes.</p></li>
<li><p><strong>nwalkers</strong> (<em>int</em><em>, </em><em>default: 1000</em>) – Number of walkers</p></li>
<li><p><strong>niteration_min</strong> (<em>int</em><em>, </em><em>optional</em>) – Steps per walker lower bound. The simulation will run at least this
number of steps per walker.</p></li>
<li><p><strong>niteration_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – Steps per walker upper bound. If the simulation runs up to
‘niteration_limit’ steps without having reached the convergence
criterion, the run is stopped.</p></li>
<li><p><strong>niteration_supp</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations to run after having “reached the convergence”.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default=0.3</em>) – The fraction of a walker which is discarded.</p></li>
<li><p><strong>rhat_threshold</strong> (<em>float</em><em>, </em><em>default=0.01</em>) – The Gelman-Rubin threshold used for the test for nonconvergence.</p></li>
<li><p><strong>rhat_count_threshold</strong> (<em>int</em><em>, </em><em>optional</em>) – The Gelman-Rubin test must be satisfied ‘rhat_count_threshold’ times in
a row before claiming that the chain has converged.</p></li>
<li><p><strong>check_maxgap</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of steps per walker between two convergence tests.</p></li>
<li><p><strong>conv_test</strong> (<em>str</em><em>, </em><em>optional {'gb'</em><em>,</em><em>'autocorr'}</em>) – Method to check for convergence:
- ‘gb’ for gelman-rubin test         (<a class="reference external" href="http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/305.pdf">http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/305.pdf</a>)
- ‘autocorr’ for autocorrelation analysis         (<a class="reference external" href="https://emcee.readthedocs.io/en/stable/tutorials/autocorr/">https://emcee.readthedocs.io/en/stable/tutorials/autocorr/</a>)</p></li>
<li><p><strong>nproc</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of processes to use for parallelization.</p></li>
<li><p><strong>grid_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the fits file containing the model grid (numpy array) AFTER
convolution+resampling as the observed spectrum given as input.
If provided, will read it if it exists (and resamp_before is set
to True), or make it and write it if it doesn’t.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>output_file</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output file which contains the MCMC results in the case
<code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>display</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the walk plot is displayed at each evaluation of the Gelman-
Rubin test.</p></li>
<li><p><strong>verbosity</strong> (<em>0</em><em>, </em><em>1</em><em> or </em><em>2</em><em>, </em><em>optional</em>) – Verbosity level. 0 for no output and 2 for full information.</p></li>
<li><p><strong>save</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the MCMC results are pickled.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out</strong> (<em>numpy.array</em>) – The MCMC samples after truncation of zeros.</p></li>
<li><p><strong>lnprobability</strong> (<em>emcee sample object</em>) – The corresponding probabilities for each sample</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The parameter <cite>a</cite> must be &gt; 1. For more theoretical information concerning
this parameter, see Goodman &amp; Weare, 2010, Comm. App. Math. Comp. Sci.,
5, 65, Eq. [9] p70.</p>
<p>The parameter ‘rhat_threshold’ can be a numpy.array with individual
threshold value for each model parameter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.show_corner_plot">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">show_corner_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mcmc_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'corner_plot.pdf'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#show_corner_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.show_corner_plot" title="Permalink to this definition"></a></dt>
<dd><p>Display/save a figure showing the corner plot (pdfs + correlation plots).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The Markov chain. The shape of chain must be nwalkers x length x dim.
If a part of the chain is filled with zero values, the method will
discard these steps.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default: 0</em>) – The fraction of a walker we want to discard.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>mcmc_res</strong> (<em>numpy array OR tuple of 2 dictionaries/np.array</em><em>, </em><em>opt</em>) – Values to be printed on top of each 1d posterior distribution
* if numpy array:         - npar x 3 dimensions (where npar is the number of parameters),         containing the most likely value of each parameter and the lower         and upper uncertainties at the desired quantiles, resp.
- npar x 2 dimensions: same as above but with a single value of          uncertainty. E.g. output of spec_confidence() for a gaussian fit
* if tuple of 2 dictionaries: output of spec_confidence without         gaussian fit
* if tuple of 2 np.array: output of spec_confidence() with gaussian fit</p></li>
<li><p><strong>units</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Tuple of strings containing units for each parameter. If provided,
mcmc_res will be printed on top of each 1d posterior distribution along
with these units.</p></li>
<li><p><strong>ndig</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Number of digits precision for each printed parameter</p></li>
<li><p><strong>labels_plot</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Labels corresponding to parameter names, used for the plot. If None,
will use “labels” passed in kwargs.</p></li>
<li><p><strong>kwargs</strong> – Additional attributes passed to the corner.corner() method.
(e.g. ‘labels’, ‘labels_tit’, ‘labels_tit_unit’, ‘title_kwargs’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Display the figure or create a pdf file named walk_plot.pdf in the working</em></p></li>
<li><p><em>directory.</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ImportError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.show_walk_plot">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">show_walk_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#show_walk_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.show_walk_plot" title="Permalink to this definition"></a></dt>
<dd><p>Display/save a figure showing the path of each walker during the MCMC run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The Markov chain. The shape of chain must be nwalkers x length x dim.
If a part of the chain is filled with zero values, the method will
discard these steps.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- next the planet photometric radius ‘R’,
- (optionally) the optical extinction ‘Av’.
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb
contribution</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>ntrunc</strong> (<em>int</em><em>, </em><em>opt</em>) – max number of walkers plotted. If too many walkers the plot will become
too voluminous and too crowded. Plot will be truncated to only ntrunc
first walkers</p></li>
<li><p><strong>kwargs</strong> – Additional attributes are passed to the matplotlib plot method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Display the figure or create a pdf file named walk_plot.pdf in the working</em></p></li>
<li><p><em>directory.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.model_resampling">
<span id="special-model-resampling"></span><h1>special.model_resampling<a class="headerlink" href="#module-special.model_resampling" title="Permalink to this headline"></a></h1>
<p>Functions useful for spectral fitting of companions, and model interpolation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.interpolate_model">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">interpolate_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params_em</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dlbda</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0002</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#interpolate_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.interpolate_model" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
</ul>
</p></li>
<li><p><strong>params_em</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Set of emission line parameters (typically fluxes) for which the model
grid has to be interpolated.</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines. Note: length of this dictionary can be different of em_lines;
i.e. if a line is in em_lines but not in em_grid, it will not be
considered an MCMC parameter.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
3 values: 1) the wavelength (in mu), 2) a string indicating whether line
intensity is expressed in flux (‘F’), luminosity (‘L’) or log(L/LSun)
(“LogL”), and 3) the latter quantity. The intensity of the emission
lines can be sampled by MCMC, in that case the last element of the
tuple can be set to None. If not to be sampled, a value for the
intensity should be provided (in the same system of units as the model
spectra, multiplied by mu). Example:
em_lines = {‘BrG’:(2.1667,’F’,263)}</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
* first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
* next the planet photometric radius ‘R’, in Jupiter radius
* (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
* (optionally) the optical extinction ‘Av’, in mag
* (optionally) the ratio of total to selective optical extinction ‘Rv’
* (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.
Note: only necessary if an emission list dictionary is provided.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum.
If provided, takes precedence over filename/file_reader which would
open and read models at each step of the MCMC.
Note: if provided, it should already probe any potential emission line.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em>) – External routine that reads a model file, converts it to required
units and returns a 2D numpy array, where the first column corresponds
to wavelengths, and the second contains model values. Example below.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{0</em><em>,</em><em>1}</em>) – 0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
<li><p><strong>max_dlbda</strong> (<em>float</em><em>, </em><em>opt</em>) – Maximum delta lbda in mu allowed if binning of lbda_model is necessary.
This is necessary for grids of models (e.g. BT-SETTL) where the wavelength
sampling is not the same depending on parameters (e.g. between 4000K
and 4100K models for BT-SETTL): resampling preserving original
resolution is too prohibitive computationally.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print more information during resampling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>model</strong> (<em>2d numpy array</em>) – Interpolated model for input parameters. First column corresponds
to wavelengths, and the second contains model values.</p></li>
<li><p><em>Example file_reader</em></p></li>
<li><p><em>——————-</em></p></li>
<li><p><em>def _example_file_reader(params)</em> – ‘’’This is a minimal example for the file_reader routine to be provided
as argument to model_interpolation. The routine should only take as
inputs grid parameters, and returns as output: both the wavelengths and
model values as a 2D numpy array.
This example assumes the model is in a fits file, that is already a 2D
numpy array, where the first column is the wavelength, and 2nd column
is the corresponding model values.’’’</p>
<p>model = open_fits(filename.format(params[0],params[1]))</p>
<p>return model</p>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.make_model_from_params">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">make_model_from_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#make_model_from_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.make_model_from_params" title="Permalink to this definition"></a></dt>
<dd><p>Routine to make the model from input parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
* first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
* then the planet photometric radius ‘R’, in Jupiter radius
* (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
* (optionally) the optical extinction ‘Av’, in mag
* (optionally) the ratio of total to selective optical extinction ‘Rv’
* (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Set to None for a pure n-blackbody fit, n=1,2,…</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
<li><p>Note2: for a combined grid model + black body, just provide         the grid parameter list here, and provide values for ‘Tbbn’ and         ‘Rbbn’ in initial_state, labels and bounds.</p></li>
</ul>
</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>opt</em>) – Wavelength of observed spectrum. If provided, the model spectrum will
be resampled to match lbda_obs. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over model_name/model_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in interpolate_model()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
3 values: 1) the wavelength (in mu), 2) a string indicating whether line
intensity is expressed in flux (‘F’), luminosity (‘L’) or log(L/LSun)
(“LogL”), and 3) the latter quantity. The intensity of the emission
lines can be sampled by MCMC, in that case the last element of the
tuple can be set to None. If not to be sampled, a value for the
intensity should be provided (in the same system of units as the model
spectra, multiplied by mu). Examples:
em_lines = {‘BrG’:(2.1667,’F’,263)};
em_lines = {‘BrG’:(2.1667,’LogL’,-5.1)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It is used to infer
which part(s) of a combined spectro+photometric spectrum should involve
convolution+subsampling (model resolution higher than measurements) or
interpolation (the opposite). If not provided, will be inferred from
half-difference between consecutive lbda_obs points (i.e. inaccurate
for a combined spectrum).</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental spectral resolution(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of spectral resolution values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_res provided above, and i in
[1,n_instru] for points associated to instru_res[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default format assumed for the files:
- first row containing header;
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The model wavelength and spectrum</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.make_resampled_models">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">make_resampled_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#make_resampled_models"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.make_resampled_models" title="Permalink to this definition"></a></dt>
<dd><p>Returns a cube of models after convolution and resampling as in the
observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters. Note: model grids shouldn’t contain grids on radius and Av.</p></li>
<li><p><strong>model_grid</strong> (<em>list of 1d numpy arrays</em><em>, or </em><em>list of lists.</em>) – Available grid of model parameters (should only contain the parameter
values, not the models themselves). The latter will be loaded.
Important: 1) Make sure the bounds are within the model grid to avoid
extrapolation. 2) All keywords that are neither ‘R’, ‘Av’ nor ‘M’ will
be considered model grid parameters.
length of params, with the same order. OR ‘1bb’ or ‘2bb’ for black-body
models. In that case the model will be created on the fly at each
iteration using 1 or 2 Planck functions respectively. There are 2 params
for each Planck function: Teff and radius.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em>) – External routine that reads a model file, converts it to required
units and returns a 2D numpy array, where the first column corresponds
to wavelengths, and the second contains model values. Example below.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
3 values: 1) the wavelength (in mu), 2) a string indicating whether line
intensity is expressed in flux (‘F’), luminosity (‘L’) or log(L/LSun)
(“LogL”), and 3) the latter quantity. The intensity of the emission
lines can be sampled by MCMC, in that case the last element of the
tuple can be set to None. If not to be sampled, a value for the
intensity should be provided (in the same system of units as the model
spectra, multiplied by mu). Example:
em_lines = {‘BrG’:(2.1667,’F’,263)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines. Note: length of this dictionary can be different of em_lines;
i.e. if a line is in em_lines but not in em_grid, it will not be
considered an MCMC parameter.</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as the
observed spectrum. If higher spectral resolution, it will be convolved
with the instrumental spectral psf (if instru_res is provided) and
then binned to the same sampling. If lower spectral resolution, a
linear interpolation is performed to infer the value at the observed
spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It is used to infer
which part(s) of a combined spectro+photometric spectrum should involve
convolution+subsampling (model resolution higher than measurements) or
interpolation (the opposite). If not provided, will be inferred from
half-difference between consecutive lbda_obs points (i.e. inaccurate
for a combined spectrum).</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental spectral resolution(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of spectral resolution values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_res provided above, and i in
[1,n_instru] for points associated to instru_res[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate if models do not exist, based on closest model(s)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>resamp_mod</strong> – Grid of model spectra resampled at wavelengths matching the observed
spectrum.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.resample_model">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">resample_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#resample_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.resample_model" title="Permalink to this definition"></a></dt>
<dd><p>Convolve, interpolate and resample a model spectrum to match observed
spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as the
observed spectrum. If higher spectral resolution, it will be convolved
with the instrumental spectral psf (if instru_res is provided) and
then binned to the same sampling. If lower spectral resolution, a
linear interpolation is performed to infer the value at the observed
spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It is used to infer
which part(s) of a combined spectro+photometric spectrum should involve
convolution+subsampling (model resolution higher than measurements) or
interpolation (the opposite). If not provided, will be inferred from
half-difference between consecutive lbda_obs points (i.e. inaccurate
for a combined spectrum).</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental spectral resolution(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of spectral resolution values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_res provided above, and i in
[1,n_instru] for points associated to instru_res[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>no_constraint</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to True, will not use ‘floor’ and ‘ceil’ constraints when
cropping the model wavelength ranges, i.e. faces the risk of
extrapolation. May be useful, if the bounds of the wavelength ranges
are known to match exactly.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print more information during resampling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>lbda_obs, spec_mod_res</strong> – Observed lambdas, and resampled model spectrum (at those lambdas)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2x 1d numpy array</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="special-nested-sampling">
<h1>special.nested_sampling<a class="headerlink" href="#special-nested-sampling" title="Permalink to this headline"></a></h1>
</div>
<div class="section" id="module-special.spec_corr">
<span id="special-spec-corr"></span><h1>special.spec_corr<a class="headerlink" href="#module-special.spec_corr" title="Permalink to this headline"></a></h1>
<p>Module to estimate the spectral correlation between channels of an IFS datacube.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.spec_corr.combine_spec_corrs">
<span class="sig-prename descclassname"><span class="pre">special.spec_corr.</span></span><span class="sig-name descname"><span class="pre">combine_spec_corrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_corr.html#combine_spec_corrs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_corr.combine_spec_corrs" title="Permalink to this definition"></a></dt>
<dd><p>Combines the spectral correlation matrices of different instruments
into a single square matrix (required for input of spectral fits).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr_list</strong> (<em>list</em><em> or </em><em>tuple of numpy ndarrays</em>) – List/tuple containing the distinct square spectral correlation matrices
OR ones (for independent photometric measurements).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>combi_corr</strong> – 2d square ndarray representing the combined spectral correlation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy 2d ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_corr.spectral_correlation">
<span class="sig-prename descclassname"><span class="pre">special.spec_corr.</span></span><span class="sig-name descname"><span class="pre">spectral_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">awidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pl_xy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sp_fwhm_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_corr.html#spectral_correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_corr.spectral_correlation" title="Permalink to this definition"></a></dt>
<dd><p>Computes the spectral correlation between (post-processed) IFS frames,
as a function of radius, implemented as Eq. 7 of Greco &amp; Brandt 2017. This
is a crucial step for an unbias fit of a measured IFS spectrum to either
synthetic or template spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>numpy ndarray</em>) – Input cube or 3d array, of dimensions n_ch x n_y x n_x; where n_y and
n_x should be odd values (star should be centered on central pixel).</p></li>
<li><p><strong>awidth</strong> (<em>int</em><em>, </em><em>optional</em>) – Width in pixels of the concentric annuli used to compute the spectral
correlation as a function of radial separation. Greco &amp; Brandt 2017
noted no significant differences for annuli between 1 and 3 pixels
width on GPI data.</p></li>
<li><p><strong>r_in</strong> (<em>int</em><em>, </em><em>optional</em>) – Innermost radius where the spectral correlation starts to be computed.</p></li>
<li><p><strong>r_out</strong> (<em>int</em><em>, </em><em>optional</em>) – Outermost radius where the spectral correlation is computed. If left as
None, it will automatically be computed up to the edge of the frame.</p></li>
<li><p><strong>pl_xy</strong> (<em>tuple of tuples of 2 floats</em><em>, </em><em>optional</em>) – x,y coordinates of all companions present in the images. If provided,
a circle centered on the location of each companion will be masked out
for the spectral correlation computation.</p></li>
<li><p><strong>mask_r</strong> (<em>float</em><em>, </em><em>optional</em>) – if pl_xy is provided, this should also be provided. Size of the
aperture around each companion (in terms of fwhm) that is discarded to
not bias the spectral correlation computation.</p></li>
<li><p><strong>fwhm</strong> (<em>float</em><em>, </em><em>optional</em>) – if pl_xy is provided, this should also be provided. By default we
consider a 2FWHM aperture mask around each companion to not bias the
spectral correlation computation.</p></li>
<li><p><strong>sp_fwhm_guess</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial guess on the spectral FWHM of all channels.</p></li>
<li><p><strong>full_output</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to also output the fitted spectral FWHM for each channel, and
the vector of radial separation at which each spectral correlation
matrix is calculated.</p></li>
<li><p><strong>Note</strong> (<em>radii that are skipped will be filled with zeros in the output cube.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sp_corr</strong> (<em>numpy ndarray</em>) – 3d array of spectral correlation, as a function of radius with
dimensions: n_rad x n_ch x n_ch, where n_rad = int((r_out-r_in)/2)</p></li>
<li><p><strong>sp_fwhm</strong> (<em>numpy ndarray</em>) – (if full_output is True) 2d array containing the spectral fwhm at each
radius, for each spectral channel. Dims: n_rad x n_ch</p></li>
<li><p><strong>sp_rad</strong> (<em>numpy ndarray</em>) – (if full_output is True) 1d array containing the radial separation of
each measured spectral correlation matrix. Dims: n_rad</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.spec_indices">
<span id="special-spec-indices"></span><h1>special.spec_indices<a class="headerlink" href="#module-special.spec_indices" title="Permalink to this headline"></a></h1>
<p>Module with utilities to estimate the spectral type and gravity of an object
based on spectral indices.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.digit_to_spt">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">digit_to_spt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'splat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#digit_to_spt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.digit_to_spt" title="Permalink to this definition"></a></dt>
<dd><p>Converts an integer index into spectral type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em><em> or </em><em>int</em>) – Index value of the spectral type</p></li>
<li><p><strong>convention</strong> (<em>str</em><em>, </em><em>optional {'splat'</em><em>, </em><em>'Allers+07'}</em>) – Which convention to use to convert digit into spectral type.
Convention from splat: K0 = 0, M0=10, L0=20, T0=30, Y9 = 49
Convention from Allers+07: M0 = 0, L0 = 10, …</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spt</strong> – String representing the spectral index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.sp_idx_to_gravity">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">sp_idx_to_gravity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Na-1.1'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#sp_idx_to_gravity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.sp_idx_to_gravity" title="Permalink to this definition"></a></dt>
<dd><p>Provides a qualitative estimate of the gravity/youth based on a
gravity-sensitive spectral index. Implemented so far:</p>
<blockquote>
<div><ul class="simple">
<li><p>the Na-1.1 index (Allers et al. 2007)</p></li>
<li><p>the CO-2.3 index (Gorlova et al. 2003)</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em>) – Value of spectral index</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional {'Na-1.1'</em><em>, </em><em>'CO-2.3'}</em>) – The name of the spectral index.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.sp_idx_to_spt">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">sp_idx_to_spt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H2O-1.5'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">young</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#sp_idx_to_spt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.sp_idx_to_spt" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Estimates a spectral type from a spectral index. Implemented so far:</dt><dd><ul class="simple">
<li><p>the H2O 1.3 mu index (Gorlova et al. 2003)</p></li>
<li><p>the H2O 1.5 mu index (Allers et al. 2007)</p></li>
<li><p>the H2O-2 index (Slesnick et al. 2004)</p></li>
</ul>
</dd>
</dl>
<p>Note on scale of SpT: 0 = M0, 10 = L0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em>) – Value of spectral index</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional {'H2O-1.3'</em><em>, </em><em>'H2O-1.5</em><em>, </em><em>'H2O-2'}</em>) – The name of the spectral index.</p></li>
<li><p><strong>idx_err</strong> (<em>float</em><em>, </em><em>optional</em>) – Uncertainty on the spectral index value</p></li>
<li><p><strong>young</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether the object is likely young (only used for ‘H2O-1.3’ index, which
is gravity dependent)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>spt</strong> (<em>float</em>) – Value of the spectral type</p></li>
<li><p><strong>spt_err</strong> (<em>float</em>) – [if idx_err is provided] Uncertainty on the spectral type.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.spectral_idx">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">spectral_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H2O-1.5'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#spectral_idx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.spectral_idx" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes a spectral index. Implemented so far:</dt><dd><ul class="simple">
<li><p>the Na 1.1 mu index (Allers et al. 2007)</p></li>
<li><p>the H2O 1.3 mu index (Gorlova et al. 2003)</p></li>
<li><p>the H2O 1.5 mu index (Allers et al. 2007)</p></li>
<li><p>the H2O 2 index (Slesnick et al. 2004)</p></li>
<li><p>the CO 2.3 index (Gorlova et al. 2003).</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>numpy ndarray</em>) – 1d numpy array containing the wavelengths of the spectrum in microns.</p></li>
<li><p><strong>spec</strong> (<em>numpy ndarray</em>) – 1d numpy array containing the measured flux (arbitrary units accepted).</p></li>
<li><p><strong>band</strong> (<em>str</em><em>, </em><em>optional {'H2O-1.5'</em><em>, </em><em>'H2O-1.3'</em><em>, </em><em>'H2O-2'</em><em>, </em><em>'Na-1.1'</em><em>, </em><em>'CO-2.3'}</em>) – Name of the band where the spectral index is defined (spectral feature
+ wavelength in mu)</p></li>
<li><p><strong>spec_err</strong> (<em>numpy ndarray</em><em>, </em><em>optional</em>) – 1d numpy array containing the uncertainties on the measured flux
(arbitrary units accepted). If provided the uncertainty on the spectral
index will also be returned.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whther to print more information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>index</strong> (<em>float</em>) – Value of the spectral index</p></li>
<li><p><strong>index_err</strong> (<em>float</em>) – [if spec_err is provided] Uncertainty on the spectral index.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.spt_to_digit">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">spt_to_digit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'splat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#spt_to_digit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.spt_to_digit" title="Permalink to this definition"></a></dt>
<dd><p>Converts a string representing spectral type into an integer index.
Convention (from splat): K0 = 0, M0=10, L0=20, T0=30, Y9 = 49</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spt</strong> (<em>str</em>) – String representing the spectral index</p></li>
<li><p><strong>convention</strong> (<em>str</em><em>, </em><em>optional {'splat'</em><em>, </em><em>'Allers+07'}</em>) – Which convention to use to convert digit into spectral type.
Convention from splat: K0 = 0, M0=10, L0=20, T0=30, Y9 = 49
Convention from Allers+07: M0 = 0, L0 = 10, …</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>idx</strong> – Index value of the spectral type</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or int</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="special-template-fit">
<h1>special.template_fit<a class="headerlink" href="#special-template-fit" title="Permalink to this headline"></a></h1>
</div>
<div class="section" id="module-special.utils_mcmc">
<span id="special-utils-mcmc"></span><h1>special.utils_mcmc<a class="headerlink" href="#module-special.utils_mcmc" title="Permalink to this headline"></a></h1>
<p>Module with utility functions to the MCMC (<code class="docutils literal notranslate"><span class="pre">emcee</span></code>) sampling for
parameter estimation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.auto_window">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">auto_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">taus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#auto_window"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.auto_window" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr_func_1d">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr_func_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr_func_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr_func_1d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr_test">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr_test" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.gelman_rubin">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">gelman_rubin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#gelman_rubin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.gelman_rubin" title="Permalink to this definition"></a></dt>
<dd><p>Determine the Gelman-Rubin hat{R} statistical test between Markov chains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>numpy.array</em>) – The numpy.array on which the Gelman-Rubin test is applied. This array
should contain at least 2 set of data, i.e. x.shape &gt;= (2,).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The Gelman-Rubin hat{R}.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gelman_rubin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1.0366629898991262</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gelman_rubin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">x1</span><span class="p">)))</span>
<span class="go">0.99</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.gelman_rubin_from_chain">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">gelman_rubin_from_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#gelman_rubin_from_chain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.gelman_rubin_from_chain" title="Permalink to this definition"></a></dt>
<dd><p>Pack the MCMC chain and determine the Gelman-Rubin hat{R} statistical
test. In other words, two sub-sets are extracted from the chain (burnin
parts are taken into account) and the Gelman-Rubin statistical test is
performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The MCMC chain with the shape walkers x steps x model_parameters</p></li>
<li><p><strong>burnin</strong> (<em>float in</em><em> [</em><em>0</em><em>,</em><em>1</em><em>]</em>) – The fraction of a walker which is discarded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The Gelman-Rubin hat{R}.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.utils_spec">
<span id="special-utils-spec"></span><h1>special.utils_spec<a class="headerlink" href="#module-special.utils_spec" title="Permalink to this headline"></a></h1>
<p>Utility functions for spectral fitting.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.akaike">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">akaike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LnL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#akaike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.akaike" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Akaike Information Criterion: 2k-2ln(L),
where k is the number of estimated parameters in the model and LnL is the
max ln-likelihood for the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LnL</strong> (<em>float</em>) – Max ln-likelihood for the considered model.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Number of estimated parameters in the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>aic</strong> – Akaike Information Criterion</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.blackbody">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">blackbody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#blackbody"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.blackbody" title="Permalink to this definition"></a></dt>
<dd><p>Planck function. Returns specific intensity for an input wavelength vector
lbda (in micrometers) and a given input temperature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>numpy array</em>) – 1d numpy array corresponding to the wavelengths (in microns) for the
desired output specific intensities.</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>B_lambda</strong> – Specific intensity corresponding to the Planck function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.convert_F_units">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">convert_F_units</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cgs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#convert_F_units"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.convert_F_units" title="Permalink to this definition"></a></dt>
<dd><p>Function to convert Flux density between [ergs s-1 cm-2 um-1],
[W m-2 um-1] and [Jy].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>float</em><em> or </em><em>1d array</em>) – Flux</p></li>
<li><p><strong>lbda</strong> (<em>float</em><em> or </em><em>1d array</em>) – Wavelength of the flux (in um)</p></li>
<li><p><strong>in_unit</strong> (<em>str</em><em>, </em><em>opt</em><em>, </em><em>{&quot;si&quot;</em><em>, </em><em>&quot;cgs&quot;</em><em>, </em><em>&quot;jy&quot;</em><em>, </em><em>&quot;cgsA&quot;}</em>) – Input flux units.
‘si’: W/m^2/mu;
‘cgs’: ergs/s/cm^2/mu
‘jy’: janskys
‘cgsA’: erg/s/cm^2/AA</p></li>
<li><p><strong>out_unit</strong> (<em>str</em><em>, </em><em>opt {&quot;si&quot;</em><em>, </em><em>&quot;cgs&quot;</em><em>, </em><em>&quot;jy&quot;}</em>) – Output flux units.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Flux in output units.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.convert_F_vs_mag">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">convert_F_vs_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Johnson'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conversion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'to_mag'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#convert_F_vs_mag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.convert_F_vs_mag" title="Permalink to this definition"></a></dt>
<dd><p>Function to convert Flux density (in Jy) to magnitude in a given band, or
the opposite.</p>
<dl class="simple">
<dt>Sources for zero points:</dt><dd><ul class="simple">
<li><p>TOKUNAGA chapter on IR astronomy (from Cohen 1992)</p></li>
<li><p>UKIRT webpage:         (<a class="reference external" href="http://www.jach.hawaii.edu/UKIRT/astronomy/calib/phot_cal/conver.html">http://www.jach.hawaii.edu/UKIRT/astronomy/calib/phot_cal/conver.html</a>)</p></li>
<li><p>van der Bliek et al. 1996 (ESO standard stars)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>float</em>) – Flux or magnitude to be converted.</p></li>
<li><p><strong>F_0</strong> (<em>float</em><em>, </em><em>opt</em>) – Zero-point flux. If provided will take precedence over band.</p></li>
<li><p><strong>band</strong> (<em>str</em><em>, </em><em>opt</em>) – Band of the given flux or magnitude. Choice between: {‘U’,’B’,’V’, ‘R’,
‘I’, ‘J’, ‘H’, ‘K’, “L”, “L’”, ‘M’, ‘N’, ‘O’}
(but not for all band systems).</p></li>
<li><p><strong>system</strong> (<em>str</em><em>, </em><em>opt</em>) – Band system. Choice between: {‘Johnson;,’2MASS’, ‘UKIRT’, ‘ESO’}</p></li>
<li><p><strong>conversion</strong> (<em>str</em><em>, </em><em>opt</em>) – In which sense to convert: flux to mag (‘to_mag’) or mag to flux
(‘to_flux’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Converted flux or magnitude.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.extinction">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">extinction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RV</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#extinction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.extinction" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the A(lambda) extinction for a given combination of A_V and R_V.
If R_V is not provided, assumes an ISM value of R_V=3.1
Uses the Cardelli et al. (1989) empirical formulas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>1d np.ndarray</em>) – Array with the wavelengths (um) for which the extinction is calculated.</p></li>
<li><p><strong>AV</strong> (<em>float</em>) – Extinction (mag) in the V band.</p></li>
<li><p><strong>RV</strong> (<em>float</em><em>, </em><em>opt</em>) – Reddening in the V band: R_V = A_V / E(B-V)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Albda</strong> – Extinction (mag) at wavelengths lbda.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.find_nearest">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">find_nearest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'index'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#find_nearest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.find_nearest" title="Permalink to this definition"></a></dt>
<dd><p>Function to find the indices, and optionally the values, of an array’s n
closest elements to a certain value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>1d numpy array</em><em> or </em><em>list</em>) – Array in which to check the closest element to value.</p></li>
<li><p><strong>value</strong> (<em>float</em>) – Value for which the algorithm searches for the n closest elements in
the array.</p></li>
<li><p><strong>output</strong> (<em>str</em><em>, </em><em>opt {'index'</em><em>,</em><em>'value'</em><em>,</em><em>'both' }</em>) – Set what is returned</p></li>
<li><p><strong>constraint</strong> (<em>str</em><em>, </em><em>opt {None</em><em>, </em><em>'ceil'</em><em>, </em><em>'floor'}</em>) – If not None, will check for the closest element larger than value (ceil)
or closest element smaller than value (floor).</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>opt</em>) – Number of elements to be returned, sorted by proximity to the values.
Default: only the closest value is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Either</em> – (output=’index’): index/indices of the closest n value(s) in the array;
(output=’value’): the closest n value(s) in the array,
(output=’both’): closest value(s) and index/-ices, respectively.</p></li>
<li><p><em>By default, only returns the index/indices.</em></p></li>
<li><p><strong>Possible constraints</strong> (<em>‘ceil’, ‘floor’, None (“ceil” will return the closest</em>)</p></li>
<li><p><em>element with a value greater than ‘value’, “floor” the opposite)</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.inject_em_line">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">inject_em_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#inject_em_line"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.inject_em_line" title="Permalink to this definition"></a></dt>
<dd><p>Injects an emission (or absorption) line in a spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wl</strong> (<em>float</em>) – Wavelength of the line</p></li>
<li><p><strong>flux</strong> (<em>float</em>) – Flux of the line to be injected</p></li>
<li><p><strong>lbda</strong> (<em>1d np.ndarray</em>) – Array with the wavelengths (um) of the input spectrum.</p></li>
<li><p><strong>spec</strong> (<em>1d np.ndarray</em>) – Input spectrum fluxes</p></li>
<li><p><strong>width</strong> (<em>float</em><em>, </em><em>opt</em>) – Full width of the line in mu (see also height). The line will be
injected assuming a gaussian profile. If not provided, the width will
be set to the ‘equivalent width’ of the line.</p></li>
<li><p><strong>height</strong> (<em>float</em><em>, </em><em>opt</em>) – Ratio to peak where the line width is considered. E.g. if
height=10%, the width will be the full width at 10% maximum.</p></li>
<li><p><strong>em</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether emission (True) or absorption (False) line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spec</strong> – Spectrum with the injected line</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.mj_from_rj_and_logg">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">mj_from_rj_and_logg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logg</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#mj_from_rj_and_logg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.mj_from_rj_and_logg" title="Permalink to this definition"></a></dt>
<dd><p>Estimates a planet mass in Jupiter mass for a given radius in Jupiter
radius and the log of the surface gravity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rp</strong> (<em>float</em>) – Planet radius in Jupiter radii</p></li>
<li><p><strong>logg</strong> (<em>float</em>) – Log of the surface gravity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mj</strong> – Planet mass in Jupiter masses</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.nrefrac">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">nrefrac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#nrefrac"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.nrefrac" title="Permalink to this definition"></a></dt>
<dd><p>Calculates refractive index of air from Cauchy formula.
For comparisong to measurements from the ground, the wavelenghts of model
spectra must be slightly shifted using:
lbda_shift = lbda_model/(1+(nrefrac*1e-6))</p>
<p>Input: wavelength in Angstrom,
Returns N = (n-1) * 1.e6.
Credit: France Allard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavelength</strong> (<em>numpy array</em>) – 1d numpy array corresponding to the wavelengths of the input spectrum
in Angstrom</p></li>
<li><p><strong>density</strong> (<em>float</em>) – density of air in amagat (relative to STP, e.g. ~10% decrease per 1000m
above sea level).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>N</strong> – Refractive index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="about.html" class="btn btn-neutral float-left" title="Contributions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Valentin Christiaens.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>